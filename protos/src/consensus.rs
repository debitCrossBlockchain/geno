// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `consensus.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct Consensus {
    // message fields
    pub consensus_type: ConsensusType,
    pub msg: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Consensus {
    fn default() -> &'a Consensus {
        <Consensus as ::protobuf::Message>::default_instance()
    }
}

impl Consensus {
    pub fn new() -> Consensus {
        ::std::default::Default::default()
    }

    // .ConsensusType consensus_type = 1;


    pub fn get_consensus_type(&self) -> ConsensusType {
        self.consensus_type
    }
    pub fn clear_consensus_type(&mut self) {
        self.consensus_type = ConsensusType::PBFT;
    }

    // Param is passed by value, moved
    pub fn set_consensus_type(&mut self, v: ConsensusType) {
        self.consensus_type = v;
    }

    // bytes msg = 2;


    pub fn get_msg(&self) -> &[u8] {
        &self.msg
    }
    pub fn clear_msg(&mut self) {
        self.msg.clear();
    }

    // Param is passed by value, moved
    pub fn set_msg(&mut self, v: ::std::vec::Vec<u8>) {
        self.msg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.msg
    }

    // Take field
    pub fn take_msg(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.msg, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Consensus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.consensus_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.msg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.consensus_type != ConsensusType::PBFT {
            my_size += ::protobuf::rt::enum_size(1, self.consensus_type);
        }
        if !self.msg.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.msg);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.consensus_type != ConsensusType::PBFT {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.consensus_type))?;
        }
        if !self.msg.is_empty() {
            os.write_bytes(2, &self.msg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Consensus {
        Consensus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ConsensusType>>(
                "consensus_type",
                |m: &Consensus| { &m.consensus_type },
                |m: &mut Consensus| { &mut m.consensus_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "msg",
                |m: &Consensus| { &m.msg },
                |m: &mut Consensus| { &mut m.msg },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Consensus>(
                "Consensus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Consensus {
        static instance: ::protobuf::rt::LazyV2<Consensus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Consensus::new)
    }
}

impl ::protobuf::Clear for Consensus {
    fn clear(&mut self) {
        self.consensus_type = ConsensusType::PBFT;
        self.msg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Consensus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Consensus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConsensusProof {
    // message fields
    pub consensus_type: ConsensusType,
    pub proof: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConsensusProof {
    fn default() -> &'a ConsensusProof {
        <ConsensusProof as ::protobuf::Message>::default_instance()
    }
}

impl ConsensusProof {
    pub fn new() -> ConsensusProof {
        ::std::default::Default::default()
    }

    // .ConsensusType consensus_type = 1;


    pub fn get_consensus_type(&self) -> ConsensusType {
        self.consensus_type
    }
    pub fn clear_consensus_type(&mut self) {
        self.consensus_type = ConsensusType::PBFT;
    }

    // Param is passed by value, moved
    pub fn set_consensus_type(&mut self, v: ConsensusType) {
        self.consensus_type = v;
    }

    // bytes proof = 2;


    pub fn get_proof(&self) -> &[u8] {
        &self.proof
    }
    pub fn clear_proof(&mut self) {
        self.proof.clear();
    }

    // Param is passed by value, moved
    pub fn set_proof(&mut self, v: ::std::vec::Vec<u8>) {
        self.proof = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proof(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.proof
    }

    // Take field
    pub fn take_proof(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.proof, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ConsensusProof {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.consensus_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.proof)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.consensus_type != ConsensusType::PBFT {
            my_size += ::protobuf::rt::enum_size(1, self.consensus_type);
        }
        if !self.proof.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.proof);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.consensus_type != ConsensusType::PBFT {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.consensus_type))?;
        }
        if !self.proof.is_empty() {
            os.write_bytes(2, &self.proof)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConsensusProof {
        ConsensusProof::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ConsensusType>>(
                "consensus_type",
                |m: &ConsensusProof| { &m.consensus_type },
                |m: &mut ConsensusProof| { &mut m.consensus_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "proof",
                |m: &ConsensusProof| { &m.proof },
                |m: &mut ConsensusProof| { &mut m.proof },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConsensusProof>(
                "ConsensusProof",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConsensusProof {
        static instance: ::protobuf::rt::LazyV2<ConsensusProof> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConsensusProof::new)
    }
}

impl ::protobuf::Clear for ConsensusProof {
    fn clear(&mut self) {
        self.consensus_type = ConsensusType::PBFT;
        self.proof.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConsensusProof {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConsensusProof {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BftBaseInfo {
    // message fields
    pub view_number: i64,
    pub sequence: u64,
    pub replica_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BftBaseInfo {
    fn default() -> &'a BftBaseInfo {
        <BftBaseInfo as ::protobuf::Message>::default_instance()
    }
}

impl BftBaseInfo {
    pub fn new() -> BftBaseInfo {
        ::std::default::Default::default()
    }

    // int64 view_number = 1;


    pub fn get_view_number(&self) -> i64 {
        self.view_number
    }
    pub fn clear_view_number(&mut self) {
        self.view_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_view_number(&mut self, v: i64) {
        self.view_number = v;
    }

    // uint64 sequence = 2;


    pub fn get_sequence(&self) -> u64 {
        self.sequence
    }
    pub fn clear_sequence(&mut self) {
        self.sequence = 0;
    }

    // Param is passed by value, moved
    pub fn set_sequence(&mut self, v: u64) {
        self.sequence = v;
    }

    // int64 replica_id = 3;


    pub fn get_replica_id(&self) -> i64 {
        self.replica_id
    }
    pub fn clear_replica_id(&mut self) {
        self.replica_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_replica_id(&mut self, v: i64) {
        self.replica_id = v;
    }
}

impl ::protobuf::Message for BftBaseInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.view_number = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sequence = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.replica_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.view_number != 0 {
            my_size += ::protobuf::rt::value_size(1, self.view_number, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sequence != 0 {
            my_size += ::protobuf::rt::value_size(2, self.sequence, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.replica_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.replica_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.view_number != 0 {
            os.write_int64(1, self.view_number)?;
        }
        if self.sequence != 0 {
            os.write_uint64(2, self.sequence)?;
        }
        if self.replica_id != 0 {
            os.write_int64(3, self.replica_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BftBaseInfo {
        BftBaseInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "view_number",
                |m: &BftBaseInfo| { &m.view_number },
                |m: &mut BftBaseInfo| { &mut m.view_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "sequence",
                |m: &BftBaseInfo| { &m.sequence },
                |m: &mut BftBaseInfo| { &mut m.sequence },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "replica_id",
                |m: &BftBaseInfo| { &m.replica_id },
                |m: &mut BftBaseInfo| { &mut m.replica_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BftBaseInfo>(
                "BftBaseInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BftBaseInfo {
        static instance: ::protobuf::rt::LazyV2<BftBaseInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BftBaseInfo::new)
    }
}

impl ::protobuf::Clear for BftBaseInfo {
    fn clear(&mut self) {
        self.view_number = 0;
        self.sequence = 0;
        self.replica_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BftBaseInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BftBaseInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BftPrePrepare {
    // message fields
    pub base: ::protobuf::SingularPtrField<BftBaseInfo>,
    pub value: ::std::vec::Vec<u8>,
    pub value_digest: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BftPrePrepare {
    fn default() -> &'a BftPrePrepare {
        <BftPrePrepare as ::protobuf::Message>::default_instance()
    }
}

impl BftPrePrepare {
    pub fn new() -> BftPrePrepare {
        ::std::default::Default::default()
    }

    // .BftBaseInfo base = 1;


    pub fn get_base(&self) -> &BftBaseInfo {
        self.base.as_ref().unwrap_or_else(|| <BftBaseInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_base(&mut self) {
        self.base.clear();
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: BftBaseInfo) {
        self.base = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base(&mut self) -> &mut BftBaseInfo {
        if self.base.is_none() {
            self.base.set_default();
        }
        self.base.as_mut().unwrap()
    }

    // Take field
    pub fn take_base(&mut self) -> BftBaseInfo {
        self.base.take().unwrap_or_else(|| BftBaseInfo::new())
    }

    // bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // bytes value_digest = 3;


    pub fn get_value_digest(&self) -> &[u8] {
        &self.value_digest
    }
    pub fn clear_value_digest(&mut self) {
        self.value_digest.clear();
    }

    // Param is passed by value, moved
    pub fn set_value_digest(&mut self, v: ::std::vec::Vec<u8>) {
        self.value_digest = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value_digest(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value_digest
    }

    // Take field
    pub fn take_value_digest(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value_digest, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BftPrePrepare {
    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.base)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value_digest)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        if !self.value_digest.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.value_digest);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.base.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        if !self.value_digest.is_empty() {
            os.write_bytes(3, &self.value_digest)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BftPrePrepare {
        BftPrePrepare::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BftBaseInfo>>(
                "base",
                |m: &BftPrePrepare| { &m.base },
                |m: &mut BftPrePrepare| { &mut m.base },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value",
                |m: &BftPrePrepare| { &m.value },
                |m: &mut BftPrePrepare| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value_digest",
                |m: &BftPrePrepare| { &m.value_digest },
                |m: &mut BftPrePrepare| { &mut m.value_digest },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BftPrePrepare>(
                "BftPrePrepare",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BftPrePrepare {
        static instance: ::protobuf::rt::LazyV2<BftPrePrepare> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BftPrePrepare::new)
    }
}

impl ::protobuf::Clear for BftPrePrepare {
    fn clear(&mut self) {
        self.base.clear();
        self.value.clear();
        self.value_digest.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BftPrePrepare {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BftPrePrepare {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BftPrepare {
    // message fields
    pub base: ::protobuf::SingularPtrField<BftBaseInfo>,
    pub value_digest: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BftPrepare {
    fn default() -> &'a BftPrepare {
        <BftPrepare as ::protobuf::Message>::default_instance()
    }
}

impl BftPrepare {
    pub fn new() -> BftPrepare {
        ::std::default::Default::default()
    }

    // .BftBaseInfo base = 1;


    pub fn get_base(&self) -> &BftBaseInfo {
        self.base.as_ref().unwrap_or_else(|| <BftBaseInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_base(&mut self) {
        self.base.clear();
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: BftBaseInfo) {
        self.base = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base(&mut self) -> &mut BftBaseInfo {
        if self.base.is_none() {
            self.base.set_default();
        }
        self.base.as_mut().unwrap()
    }

    // Take field
    pub fn take_base(&mut self) -> BftBaseInfo {
        self.base.take().unwrap_or_else(|| BftBaseInfo::new())
    }

    // bytes value_digest = 2;


    pub fn get_value_digest(&self) -> &[u8] {
        &self.value_digest
    }
    pub fn clear_value_digest(&mut self) {
        self.value_digest.clear();
    }

    // Param is passed by value, moved
    pub fn set_value_digest(&mut self, v: ::std::vec::Vec<u8>) {
        self.value_digest = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value_digest(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value_digest
    }

    // Take field
    pub fn take_value_digest(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value_digest, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BftPrepare {
    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.base)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value_digest)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.value_digest.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value_digest);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.base.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.value_digest.is_empty() {
            os.write_bytes(2, &self.value_digest)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BftPrepare {
        BftPrepare::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BftBaseInfo>>(
                "base",
                |m: &BftPrepare| { &m.base },
                |m: &mut BftPrepare| { &mut m.base },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value_digest",
                |m: &BftPrepare| { &m.value_digest },
                |m: &mut BftPrepare| { &mut m.value_digest },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BftPrepare>(
                "BftPrepare",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BftPrepare {
        static instance: ::protobuf::rt::LazyV2<BftPrepare> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BftPrepare::new)
    }
}

impl ::protobuf::Clear for BftPrepare {
    fn clear(&mut self) {
        self.base.clear();
        self.value_digest.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BftPrepare {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BftPrepare {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BftCommit {
    // message fields
    pub base: ::protobuf::SingularPtrField<BftBaseInfo>,
    pub value_digest: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BftCommit {
    fn default() -> &'a BftCommit {
        <BftCommit as ::protobuf::Message>::default_instance()
    }
}

impl BftCommit {
    pub fn new() -> BftCommit {
        ::std::default::Default::default()
    }

    // .BftBaseInfo base = 1;


    pub fn get_base(&self) -> &BftBaseInfo {
        self.base.as_ref().unwrap_or_else(|| <BftBaseInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_base(&mut self) {
        self.base.clear();
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: BftBaseInfo) {
        self.base = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base(&mut self) -> &mut BftBaseInfo {
        if self.base.is_none() {
            self.base.set_default();
        }
        self.base.as_mut().unwrap()
    }

    // Take field
    pub fn take_base(&mut self) -> BftBaseInfo {
        self.base.take().unwrap_or_else(|| BftBaseInfo::new())
    }

    // bytes value_digest = 2;


    pub fn get_value_digest(&self) -> &[u8] {
        &self.value_digest
    }
    pub fn clear_value_digest(&mut self) {
        self.value_digest.clear();
    }

    // Param is passed by value, moved
    pub fn set_value_digest(&mut self, v: ::std::vec::Vec<u8>) {
        self.value_digest = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value_digest(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value_digest
    }

    // Take field
    pub fn take_value_digest(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value_digest, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BftCommit {
    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.base)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value_digest)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.value_digest.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value_digest);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.base.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.value_digest.is_empty() {
            os.write_bytes(2, &self.value_digest)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BftCommit {
        BftCommit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BftBaseInfo>>(
                "base",
                |m: &BftCommit| { &m.base },
                |m: &mut BftCommit| { &mut m.base },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value_digest",
                |m: &BftCommit| { &m.value_digest },
                |m: &mut BftCommit| { &mut m.value_digest },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BftCommit>(
                "BftCommit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BftCommit {
        static instance: ::protobuf::rt::LazyV2<BftCommit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BftCommit::new)
    }
}

impl ::protobuf::Clear for BftCommit {
    fn clear(&mut self) {
        self.base.clear();
        self.value_digest.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BftCommit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BftCommit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BftPreparedSet {
    // message fields
    pub pre_prepare: ::protobuf::SingularPtrField<BftSign>,
    pub prepare: ::protobuf::RepeatedField<BftSign>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BftPreparedSet {
    fn default() -> &'a BftPreparedSet {
        <BftPreparedSet as ::protobuf::Message>::default_instance()
    }
}

impl BftPreparedSet {
    pub fn new() -> BftPreparedSet {
        ::std::default::Default::default()
    }

    // .BftSign pre_prepare = 1;


    pub fn get_pre_prepare(&self) -> &BftSign {
        self.pre_prepare.as_ref().unwrap_or_else(|| <BftSign as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pre_prepare(&mut self) {
        self.pre_prepare.clear();
    }

    pub fn has_pre_prepare(&self) -> bool {
        self.pre_prepare.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pre_prepare(&mut self, v: BftSign) {
        self.pre_prepare = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pre_prepare(&mut self) -> &mut BftSign {
        if self.pre_prepare.is_none() {
            self.pre_prepare.set_default();
        }
        self.pre_prepare.as_mut().unwrap()
    }

    // Take field
    pub fn take_pre_prepare(&mut self) -> BftSign {
        self.pre_prepare.take().unwrap_or_else(|| BftSign::new())
    }

    // repeated .BftSign prepare = 2;


    pub fn get_prepare(&self) -> &[BftSign] {
        &self.prepare
    }
    pub fn clear_prepare(&mut self) {
        self.prepare.clear();
    }

    // Param is passed by value, moved
    pub fn set_prepare(&mut self, v: ::protobuf::RepeatedField<BftSign>) {
        self.prepare = v;
    }

    // Mutable pointer to the field.
    pub fn mut_prepare(&mut self) -> &mut ::protobuf::RepeatedField<BftSign> {
        &mut self.prepare
    }

    // Take field
    pub fn take_prepare(&mut self) -> ::protobuf::RepeatedField<BftSign> {
        ::std::mem::replace(&mut self.prepare, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BftPreparedSet {
    fn is_initialized(&self) -> bool {
        for v in &self.pre_prepare {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.prepare {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pre_prepare)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.prepare)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pre_prepare.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.prepare {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pre_prepare.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.prepare {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BftPreparedSet {
        BftPreparedSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BftSign>>(
                "pre_prepare",
                |m: &BftPreparedSet| { &m.pre_prepare },
                |m: &mut BftPreparedSet| { &mut m.pre_prepare },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BftSign>>(
                "prepare",
                |m: &BftPreparedSet| { &m.prepare },
                |m: &mut BftPreparedSet| { &mut m.prepare },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BftPreparedSet>(
                "BftPreparedSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BftPreparedSet {
        static instance: ::protobuf::rt::LazyV2<BftPreparedSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BftPreparedSet::new)
    }
}

impl ::protobuf::Clear for BftPreparedSet {
    fn clear(&mut self) {
        self.pre_prepare.clear();
        self.prepare.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BftPreparedSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BftPreparedSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BftViewChange {
    // message fields
    pub base: ::protobuf::SingularPtrField<BftBaseInfo>,
    pub prepared_value_digest: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BftViewChange {
    fn default() -> &'a BftViewChange {
        <BftViewChange as ::protobuf::Message>::default_instance()
    }
}

impl BftViewChange {
    pub fn new() -> BftViewChange {
        ::std::default::Default::default()
    }

    // .BftBaseInfo base = 1;


    pub fn get_base(&self) -> &BftBaseInfo {
        self.base.as_ref().unwrap_or_else(|| <BftBaseInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_base(&mut self) {
        self.base.clear();
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: BftBaseInfo) {
        self.base = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base(&mut self) -> &mut BftBaseInfo {
        if self.base.is_none() {
            self.base.set_default();
        }
        self.base.as_mut().unwrap()
    }

    // Take field
    pub fn take_base(&mut self) -> BftBaseInfo {
        self.base.take().unwrap_or_else(|| BftBaseInfo::new())
    }

    // bytes prepared_value_digest = 2;


    pub fn get_prepared_value_digest(&self) -> &[u8] {
        &self.prepared_value_digest
    }
    pub fn clear_prepared_value_digest(&mut self) {
        self.prepared_value_digest.clear();
    }

    // Param is passed by value, moved
    pub fn set_prepared_value_digest(&mut self, v: ::std::vec::Vec<u8>) {
        self.prepared_value_digest = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prepared_value_digest(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.prepared_value_digest
    }

    // Take field
    pub fn take_prepared_value_digest(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.prepared_value_digest, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BftViewChange {
    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.base)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.prepared_value_digest)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.prepared_value_digest.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.prepared_value_digest);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.base.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.prepared_value_digest.is_empty() {
            os.write_bytes(2, &self.prepared_value_digest)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BftViewChange {
        BftViewChange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BftBaseInfo>>(
                "base",
                |m: &BftViewChange| { &m.base },
                |m: &mut BftViewChange| { &mut m.base },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "prepared_value_digest",
                |m: &BftViewChange| { &m.prepared_value_digest },
                |m: &mut BftViewChange| { &mut m.prepared_value_digest },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BftViewChange>(
                "BftViewChange",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BftViewChange {
        static instance: ::protobuf::rt::LazyV2<BftViewChange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BftViewChange::new)
    }
}

impl ::protobuf::Clear for BftViewChange {
    fn clear(&mut self) {
        self.base.clear();
        self.prepared_value_digest.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BftViewChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BftViewChange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BftViewChangeValue {
    // message fields
    pub view_change_env: ::protobuf::SingularPtrField<BftSign>,
    pub prepared_set: ::protobuf::SingularPtrField<BftPreparedSet>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BftViewChangeValue {
    fn default() -> &'a BftViewChangeValue {
        <BftViewChangeValue as ::protobuf::Message>::default_instance()
    }
}

impl BftViewChangeValue {
    pub fn new() -> BftViewChangeValue {
        ::std::default::Default::default()
    }

    // .BftSign view_change_env = 1;


    pub fn get_view_change_env(&self) -> &BftSign {
        self.view_change_env.as_ref().unwrap_or_else(|| <BftSign as ::protobuf::Message>::default_instance())
    }
    pub fn clear_view_change_env(&mut self) {
        self.view_change_env.clear();
    }

    pub fn has_view_change_env(&self) -> bool {
        self.view_change_env.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_change_env(&mut self, v: BftSign) {
        self.view_change_env = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_view_change_env(&mut self) -> &mut BftSign {
        if self.view_change_env.is_none() {
            self.view_change_env.set_default();
        }
        self.view_change_env.as_mut().unwrap()
    }

    // Take field
    pub fn take_view_change_env(&mut self) -> BftSign {
        self.view_change_env.take().unwrap_or_else(|| BftSign::new())
    }

    // .BftPreparedSet prepared_set = 2;


    pub fn get_prepared_set(&self) -> &BftPreparedSet {
        self.prepared_set.as_ref().unwrap_or_else(|| <BftPreparedSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_prepared_set(&mut self) {
        self.prepared_set.clear();
    }

    pub fn has_prepared_set(&self) -> bool {
        self.prepared_set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prepared_set(&mut self, v: BftPreparedSet) {
        self.prepared_set = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prepared_set(&mut self) -> &mut BftPreparedSet {
        if self.prepared_set.is_none() {
            self.prepared_set.set_default();
        }
        self.prepared_set.as_mut().unwrap()
    }

    // Take field
    pub fn take_prepared_set(&mut self) -> BftPreparedSet {
        self.prepared_set.take().unwrap_or_else(|| BftPreparedSet::new())
    }
}

impl ::protobuf::Message for BftViewChangeValue {
    fn is_initialized(&self) -> bool {
        for v in &self.view_change_env {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.prepared_set {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.view_change_env)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.prepared_set)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.view_change_env.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.prepared_set.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.view_change_env.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.prepared_set.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BftViewChangeValue {
        BftViewChangeValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BftSign>>(
                "view_change_env",
                |m: &BftViewChangeValue| { &m.view_change_env },
                |m: &mut BftViewChangeValue| { &mut m.view_change_env },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BftPreparedSet>>(
                "prepared_set",
                |m: &BftViewChangeValue| { &m.prepared_set },
                |m: &mut BftViewChangeValue| { &mut m.prepared_set },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BftViewChangeValue>(
                "BftViewChangeValue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BftViewChangeValue {
        static instance: ::protobuf::rt::LazyV2<BftViewChangeValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BftViewChangeValue::new)
    }
}

impl ::protobuf::Clear for BftViewChangeValue {
    fn clear(&mut self) {
        self.view_change_env.clear();
        self.prepared_set.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BftViewChangeValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BftViewChangeValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BftNewView {
    // message fields
    pub base: ::protobuf::SingularPtrField<BftBaseInfo>,
    pub view_changes: ::protobuf::RepeatedField<BftSign>,
    pub pre_prepare: ::protobuf::SingularPtrField<BftSign>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BftNewView {
    fn default() -> &'a BftNewView {
        <BftNewView as ::protobuf::Message>::default_instance()
    }
}

impl BftNewView {
    pub fn new() -> BftNewView {
        ::std::default::Default::default()
    }

    // .BftBaseInfo base = 1;


    pub fn get_base(&self) -> &BftBaseInfo {
        self.base.as_ref().unwrap_or_else(|| <BftBaseInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_base(&mut self) {
        self.base.clear();
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: BftBaseInfo) {
        self.base = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base(&mut self) -> &mut BftBaseInfo {
        if self.base.is_none() {
            self.base.set_default();
        }
        self.base.as_mut().unwrap()
    }

    // Take field
    pub fn take_base(&mut self) -> BftBaseInfo {
        self.base.take().unwrap_or_else(|| BftBaseInfo::new())
    }

    // repeated .BftSign view_changes = 2;


    pub fn get_view_changes(&self) -> &[BftSign] {
        &self.view_changes
    }
    pub fn clear_view_changes(&mut self) {
        self.view_changes.clear();
    }

    // Param is passed by value, moved
    pub fn set_view_changes(&mut self, v: ::protobuf::RepeatedField<BftSign>) {
        self.view_changes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_view_changes(&mut self) -> &mut ::protobuf::RepeatedField<BftSign> {
        &mut self.view_changes
    }

    // Take field
    pub fn take_view_changes(&mut self) -> ::protobuf::RepeatedField<BftSign> {
        ::std::mem::replace(&mut self.view_changes, ::protobuf::RepeatedField::new())
    }

    // .BftSign pre_prepare = 3;


    pub fn get_pre_prepare(&self) -> &BftSign {
        self.pre_prepare.as_ref().unwrap_or_else(|| <BftSign as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pre_prepare(&mut self) {
        self.pre_prepare.clear();
    }

    pub fn has_pre_prepare(&self) -> bool {
        self.pre_prepare.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pre_prepare(&mut self, v: BftSign) {
        self.pre_prepare = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pre_prepare(&mut self) -> &mut BftSign {
        if self.pre_prepare.is_none() {
            self.pre_prepare.set_default();
        }
        self.pre_prepare.as_mut().unwrap()
    }

    // Take field
    pub fn take_pre_prepare(&mut self) -> BftSign {
        self.pre_prepare.take().unwrap_or_else(|| BftSign::new())
    }
}

impl ::protobuf::Message for BftNewView {
    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.view_changes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pre_prepare {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.base)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.view_changes)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pre_prepare)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.view_changes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.pre_prepare.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.base.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.view_changes {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.pre_prepare.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BftNewView {
        BftNewView::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BftBaseInfo>>(
                "base",
                |m: &BftNewView| { &m.base },
                |m: &mut BftNewView| { &mut m.base },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BftSign>>(
                "view_changes",
                |m: &BftNewView| { &m.view_changes },
                |m: &mut BftNewView| { &mut m.view_changes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BftSign>>(
                "pre_prepare",
                |m: &BftNewView| { &m.pre_prepare },
                |m: &mut BftNewView| { &mut m.pre_prepare },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BftNewView>(
                "BftNewView",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BftNewView {
        static instance: ::protobuf::rt::LazyV2<BftNewView> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BftNewView::new)
    }
}

impl ::protobuf::Clear for BftNewView {
    fn clear(&mut self) {
        self.base.clear();
        self.view_changes.clear();
        self.pre_prepare.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BftNewView {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BftNewView {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Bft {
    // message fields
    pub round_number: u64,
    pub msg_type: BftMessageType,
    pub pre_prepare: ::protobuf::SingularPtrField<BftPrePrepare>,
    pub prepare: ::protobuf::SingularPtrField<BftPrepare>,
    pub commit: ::protobuf::SingularPtrField<BftCommit>,
    pub view_change: ::protobuf::SingularPtrField<BftViewChange>,
    pub new_view: ::protobuf::SingularPtrField<BftNewView>,
    pub view_change_value: ::protobuf::SingularPtrField<BftViewChangeValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Bft {
    fn default() -> &'a Bft {
        <Bft as ::protobuf::Message>::default_instance()
    }
}

impl Bft {
    pub fn new() -> Bft {
        ::std::default::Default::default()
    }

    // uint64 round_number = 1;


    pub fn get_round_number(&self) -> u64 {
        self.round_number
    }
    pub fn clear_round_number(&mut self) {
        self.round_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_round_number(&mut self, v: u64) {
        self.round_number = v;
    }

    // .BftMessageType msg_type = 2;


    pub fn get_msg_type(&self) -> BftMessageType {
        self.msg_type
    }
    pub fn clear_msg_type(&mut self) {
        self.msg_type = BftMessageType::PRE_PREPARE;
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: BftMessageType) {
        self.msg_type = v;
    }

    // .BftPrePrepare pre_prepare = 3;


    pub fn get_pre_prepare(&self) -> &BftPrePrepare {
        self.pre_prepare.as_ref().unwrap_or_else(|| <BftPrePrepare as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pre_prepare(&mut self) {
        self.pre_prepare.clear();
    }

    pub fn has_pre_prepare(&self) -> bool {
        self.pre_prepare.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pre_prepare(&mut self, v: BftPrePrepare) {
        self.pre_prepare = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pre_prepare(&mut self) -> &mut BftPrePrepare {
        if self.pre_prepare.is_none() {
            self.pre_prepare.set_default();
        }
        self.pre_prepare.as_mut().unwrap()
    }

    // Take field
    pub fn take_pre_prepare(&mut self) -> BftPrePrepare {
        self.pre_prepare.take().unwrap_or_else(|| BftPrePrepare::new())
    }

    // .BftPrepare prepare = 4;


    pub fn get_prepare(&self) -> &BftPrepare {
        self.prepare.as_ref().unwrap_or_else(|| <BftPrepare as ::protobuf::Message>::default_instance())
    }
    pub fn clear_prepare(&mut self) {
        self.prepare.clear();
    }

    pub fn has_prepare(&self) -> bool {
        self.prepare.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prepare(&mut self, v: BftPrepare) {
        self.prepare = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prepare(&mut self) -> &mut BftPrepare {
        if self.prepare.is_none() {
            self.prepare.set_default();
        }
        self.prepare.as_mut().unwrap()
    }

    // Take field
    pub fn take_prepare(&mut self) -> BftPrepare {
        self.prepare.take().unwrap_or_else(|| BftPrepare::new())
    }

    // .BftCommit commit = 5;


    pub fn get_commit(&self) -> &BftCommit {
        self.commit.as_ref().unwrap_or_else(|| <BftCommit as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commit(&mut self) {
        self.commit.clear();
    }

    pub fn has_commit(&self) -> bool {
        self.commit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commit(&mut self, v: BftCommit) {
        self.commit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commit(&mut self) -> &mut BftCommit {
        if self.commit.is_none() {
            self.commit.set_default();
        }
        self.commit.as_mut().unwrap()
    }

    // Take field
    pub fn take_commit(&mut self) -> BftCommit {
        self.commit.take().unwrap_or_else(|| BftCommit::new())
    }

    // .BftViewChange view_change = 6;


    pub fn get_view_change(&self) -> &BftViewChange {
        self.view_change.as_ref().unwrap_or_else(|| <BftViewChange as ::protobuf::Message>::default_instance())
    }
    pub fn clear_view_change(&mut self) {
        self.view_change.clear();
    }

    pub fn has_view_change(&self) -> bool {
        self.view_change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_change(&mut self, v: BftViewChange) {
        self.view_change = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_view_change(&mut self) -> &mut BftViewChange {
        if self.view_change.is_none() {
            self.view_change.set_default();
        }
        self.view_change.as_mut().unwrap()
    }

    // Take field
    pub fn take_view_change(&mut self) -> BftViewChange {
        self.view_change.take().unwrap_or_else(|| BftViewChange::new())
    }

    // .BftNewView new_view = 7;


    pub fn get_new_view(&self) -> &BftNewView {
        self.new_view.as_ref().unwrap_or_else(|| <BftNewView as ::protobuf::Message>::default_instance())
    }
    pub fn clear_new_view(&mut self) {
        self.new_view.clear();
    }

    pub fn has_new_view(&self) -> bool {
        self.new_view.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_view(&mut self, v: BftNewView) {
        self.new_view = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_new_view(&mut self) -> &mut BftNewView {
        if self.new_view.is_none() {
            self.new_view.set_default();
        }
        self.new_view.as_mut().unwrap()
    }

    // Take field
    pub fn take_new_view(&mut self) -> BftNewView {
        self.new_view.take().unwrap_or_else(|| BftNewView::new())
    }

    // .BftViewChangeValue view_change_value = 8;


    pub fn get_view_change_value(&self) -> &BftViewChangeValue {
        self.view_change_value.as_ref().unwrap_or_else(|| <BftViewChangeValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_view_change_value(&mut self) {
        self.view_change_value.clear();
    }

    pub fn has_view_change_value(&self) -> bool {
        self.view_change_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_change_value(&mut self, v: BftViewChangeValue) {
        self.view_change_value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_view_change_value(&mut self) -> &mut BftViewChangeValue {
        if self.view_change_value.is_none() {
            self.view_change_value.set_default();
        }
        self.view_change_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_view_change_value(&mut self) -> BftViewChangeValue {
        self.view_change_value.take().unwrap_or_else(|| BftViewChangeValue::new())
    }
}

impl ::protobuf::Message for Bft {
    fn is_initialized(&self) -> bool {
        for v in &self.pre_prepare {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.prepare {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.commit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.view_change {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.new_view {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.view_change_value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.round_number = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.msg_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pre_prepare)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.prepare)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commit)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.view_change)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.new_view)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.view_change_value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.round_number != 0 {
            my_size += ::protobuf::rt::value_size(1, self.round_number, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.msg_type != BftMessageType::PRE_PREPARE {
            my_size += ::protobuf::rt::enum_size(2, self.msg_type);
        }
        if let Some(ref v) = self.pre_prepare.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.prepare.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.commit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.view_change.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.new_view.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.view_change_value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.round_number != 0 {
            os.write_uint64(1, self.round_number)?;
        }
        if self.msg_type != BftMessageType::PRE_PREPARE {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.msg_type))?;
        }
        if let Some(ref v) = self.pre_prepare.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.prepare.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.commit.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.view_change.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.new_view.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.view_change_value.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Bft {
        Bft::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "round_number",
                |m: &Bft| { &m.round_number },
                |m: &mut Bft| { &mut m.round_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BftMessageType>>(
                "msg_type",
                |m: &Bft| { &m.msg_type },
                |m: &mut Bft| { &mut m.msg_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BftPrePrepare>>(
                "pre_prepare",
                |m: &Bft| { &m.pre_prepare },
                |m: &mut Bft| { &mut m.pre_prepare },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BftPrepare>>(
                "prepare",
                |m: &Bft| { &m.prepare },
                |m: &mut Bft| { &mut m.prepare },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BftCommit>>(
                "commit",
                |m: &Bft| { &m.commit },
                |m: &mut Bft| { &mut m.commit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BftViewChange>>(
                "view_change",
                |m: &Bft| { &m.view_change },
                |m: &mut Bft| { &mut m.view_change },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BftNewView>>(
                "new_view",
                |m: &Bft| { &m.new_view },
                |m: &mut Bft| { &mut m.new_view },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BftViewChangeValue>>(
                "view_change_value",
                |m: &Bft| { &m.view_change_value },
                |m: &mut Bft| { &mut m.view_change_value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Bft>(
                "Bft",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Bft {
        static instance: ::protobuf::rt::LazyV2<Bft> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Bft::new)
    }
}

impl ::protobuf::Clear for Bft {
    fn clear(&mut self) {
        self.round_number = 0;
        self.msg_type = BftMessageType::PRE_PREPARE;
        self.pre_prepare.clear();
        self.prepare.clear();
        self.commit.clear();
        self.view_change.clear();
        self.new_view.clear();
        self.view_change_value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Bft {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bft {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BftSign {
    // message fields
    pub bft: ::protobuf::SingularPtrField<Bft>,
    pub signature: ::protobuf::SingularPtrField<super::common::Signature>,
    pub chain_id: ::std::string::String,
    pub chain_hub: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BftSign {
    fn default() -> &'a BftSign {
        <BftSign as ::protobuf::Message>::default_instance()
    }
}

impl BftSign {
    pub fn new() -> BftSign {
        ::std::default::Default::default()
    }

    // .Bft bft = 1;


    pub fn get_bft(&self) -> &Bft {
        self.bft.as_ref().unwrap_or_else(|| <Bft as ::protobuf::Message>::default_instance())
    }
    pub fn clear_bft(&mut self) {
        self.bft.clear();
    }

    pub fn has_bft(&self) -> bool {
        self.bft.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bft(&mut self, v: Bft) {
        self.bft = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bft(&mut self) -> &mut Bft {
        if self.bft.is_none() {
            self.bft.set_default();
        }
        self.bft.as_mut().unwrap()
    }

    // Take field
    pub fn take_bft(&mut self) -> Bft {
        self.bft.take().unwrap_or_else(|| Bft::new())
    }

    // .Signature signature = 2;


    pub fn get_signature(&self) -> &super::common::Signature {
        self.signature.as_ref().unwrap_or_else(|| <super::common::Signature as ::protobuf::Message>::default_instance())
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: super::common::Signature) {
        self.signature = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut super::common::Signature {
        if self.signature.is_none() {
            self.signature.set_default();
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> super::common::Signature {
        self.signature.take().unwrap_or_else(|| super::common::Signature::new())
    }

    // string chain_id = 3;


    pub fn get_chain_id(&self) -> &str {
        &self.chain_id
    }
    pub fn clear_chain_id(&mut self) {
        self.chain_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_chain_id(&mut self, v: ::std::string::String) {
        self.chain_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chain_id(&mut self) -> &mut ::std::string::String {
        &mut self.chain_id
    }

    // Take field
    pub fn take_chain_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.chain_id, ::std::string::String::new())
    }

    // string chain_hub = 4;


    pub fn get_chain_hub(&self) -> &str {
        &self.chain_hub
    }
    pub fn clear_chain_hub(&mut self) {
        self.chain_hub.clear();
    }

    // Param is passed by value, moved
    pub fn set_chain_hub(&mut self, v: ::std::string::String) {
        self.chain_hub = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chain_hub(&mut self) -> &mut ::std::string::String {
        &mut self.chain_hub
    }

    // Take field
    pub fn take_chain_hub(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.chain_hub, ::std::string::String::new())
    }
}

impl ::protobuf::Message for BftSign {
    fn is_initialized(&self) -> bool {
        for v in &self.bft {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.signature {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bft)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.signature)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.chain_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.chain_hub)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.bft.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.signature.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.chain_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.chain_id);
        }
        if !self.chain_hub.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.chain_hub);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.bft.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.signature.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.chain_id.is_empty() {
            os.write_string(3, &self.chain_id)?;
        }
        if !self.chain_hub.is_empty() {
            os.write_string(4, &self.chain_hub)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BftSign {
        BftSign::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Bft>>(
                "bft",
                |m: &BftSign| { &m.bft },
                |m: &mut BftSign| { &mut m.bft },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Signature>>(
                "signature",
                |m: &BftSign| { &m.signature },
                |m: &mut BftSign| { &mut m.signature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "chain_id",
                |m: &BftSign| { &m.chain_id },
                |m: &mut BftSign| { &mut m.chain_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "chain_hub",
                |m: &BftSign| { &m.chain_hub },
                |m: &mut BftSign| { &mut m.chain_hub },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BftSign>(
                "BftSign",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BftSign {
        static instance: ::protobuf::rt::LazyV2<BftSign> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BftSign::new)
    }
}

impl ::protobuf::Clear for BftSign {
    fn clear(&mut self) {
        self.bft.clear();
        self.signature.clear();
        self.chain_id.clear();
        self.chain_hub.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BftSign {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BftSign {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BftProof {
    // message fields
    pub commits: ::protobuf::RepeatedField<BftSign>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BftProof {
    fn default() -> &'a BftProof {
        <BftProof as ::protobuf::Message>::default_instance()
    }
}

impl BftProof {
    pub fn new() -> BftProof {
        ::std::default::Default::default()
    }

    // repeated .BftSign commits = 1;


    pub fn get_commits(&self) -> &[BftSign] {
        &self.commits
    }
    pub fn clear_commits(&mut self) {
        self.commits.clear();
    }

    // Param is passed by value, moved
    pub fn set_commits(&mut self, v: ::protobuf::RepeatedField<BftSign>) {
        self.commits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_commits(&mut self) -> &mut ::protobuf::RepeatedField<BftSign> {
        &mut self.commits
    }

    // Take field
    pub fn take_commits(&mut self) -> ::protobuf::RepeatedField<BftSign> {
        ::std::mem::replace(&mut self.commits, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BftProof {
    fn is_initialized(&self) -> bool {
        for v in &self.commits {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.commits)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.commits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.commits {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BftProof {
        BftProof::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BftSign>>(
                "commits",
                |m: &BftProof| { &m.commits },
                |m: &mut BftProof| { &mut m.commits },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BftProof>(
                "BftProof",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BftProof {
        static instance: ::protobuf::rt::LazyV2<BftProof> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BftProof::new)
    }
}

impl ::protobuf::Clear for BftProof {
    fn clear(&mut self) {
        self.commits.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BftProof {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BftProof {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TxHashList {
    // message fields
    pub hash_set: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TxHashList {
    fn default() -> &'a TxHashList {
        <TxHashList as ::protobuf::Message>::default_instance()
    }
}

impl TxHashList {
    pub fn new() -> TxHashList {
        ::std::default::Default::default()
    }

    // repeated bytes hash_set = 1;


    pub fn get_hash_set(&self) -> &[::std::vec::Vec<u8>] {
        &self.hash_set
    }
    pub fn clear_hash_set(&mut self) {
        self.hash_set.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash_set(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.hash_set = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hash_set(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.hash_set
    }

    // Take field
    pub fn take_hash_set(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.hash_set, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TxHashList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.hash_set)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.hash_set {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.hash_set {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TxHashList {
        TxHashList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "hash_set",
                |m: &TxHashList| { &m.hash_set },
                |m: &mut TxHashList| { &mut m.hash_set },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TxHashList>(
                "TxHashList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TxHashList {
        static instance: ::protobuf::rt::LazyV2<TxHashList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TxHashList::new)
    }
}

impl ::protobuf::Clear for TxHashList {
    fn clear(&mut self) {
        self.hash_set.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TxHashList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TxHashList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ViewChangeStore {
    // message fields
    pub sequence: u64,
    pub view_number: i64,
    pub view_change_round: u64,
    pub start_time: u64,
    pub end_time: u64,
    pub last_propose_time: u64,
    pub last_newview_time: u64,
    pub new_view_round: u64,
    pub view_change_msg: ::protobuf::SingularPtrField<BftSign>,
    pub new_view: ::protobuf::SingularPtrField<BftSign>,
    pub msg_buffer: ::protobuf::RepeatedField<BftSign>,
    pub view_changes: ::protobuf::RepeatedField<BftViewChange>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ViewChangeStore {
    fn default() -> &'a ViewChangeStore {
        <ViewChangeStore as ::protobuf::Message>::default_instance()
    }
}

impl ViewChangeStore {
    pub fn new() -> ViewChangeStore {
        ::std::default::Default::default()
    }

    // uint64 sequence = 1;


    pub fn get_sequence(&self) -> u64 {
        self.sequence
    }
    pub fn clear_sequence(&mut self) {
        self.sequence = 0;
    }

    // Param is passed by value, moved
    pub fn set_sequence(&mut self, v: u64) {
        self.sequence = v;
    }

    // int64 view_number = 2;


    pub fn get_view_number(&self) -> i64 {
        self.view_number
    }
    pub fn clear_view_number(&mut self) {
        self.view_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_view_number(&mut self, v: i64) {
        self.view_number = v;
    }

    // uint64 view_change_round = 3;


    pub fn get_view_change_round(&self) -> u64 {
        self.view_change_round
    }
    pub fn clear_view_change_round(&mut self) {
        self.view_change_round = 0;
    }

    // Param is passed by value, moved
    pub fn set_view_change_round(&mut self, v: u64) {
        self.view_change_round = v;
    }

    // uint64 start_time = 4;


    pub fn get_start_time(&self) -> u64 {
        self.start_time
    }
    pub fn clear_start_time(&mut self) {
        self.start_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u64) {
        self.start_time = v;
    }

    // uint64 end_time = 5;


    pub fn get_end_time(&self) -> u64 {
        self.end_time
    }
    pub fn clear_end_time(&mut self) {
        self.end_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: u64) {
        self.end_time = v;
    }

    // uint64 last_propose_time = 6;


    pub fn get_last_propose_time(&self) -> u64 {
        self.last_propose_time
    }
    pub fn clear_last_propose_time(&mut self) {
        self.last_propose_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_propose_time(&mut self, v: u64) {
        self.last_propose_time = v;
    }

    // uint64 last_newview_time = 7;


    pub fn get_last_newview_time(&self) -> u64 {
        self.last_newview_time
    }
    pub fn clear_last_newview_time(&mut self) {
        self.last_newview_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_newview_time(&mut self, v: u64) {
        self.last_newview_time = v;
    }

    // uint64 new_view_round = 8;


    pub fn get_new_view_round(&self) -> u64 {
        self.new_view_round
    }
    pub fn clear_new_view_round(&mut self) {
        self.new_view_round = 0;
    }

    // Param is passed by value, moved
    pub fn set_new_view_round(&mut self, v: u64) {
        self.new_view_round = v;
    }

    // .BftSign view_change_msg = 9;


    pub fn get_view_change_msg(&self) -> &BftSign {
        self.view_change_msg.as_ref().unwrap_or_else(|| <BftSign as ::protobuf::Message>::default_instance())
    }
    pub fn clear_view_change_msg(&mut self) {
        self.view_change_msg.clear();
    }

    pub fn has_view_change_msg(&self) -> bool {
        self.view_change_msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_change_msg(&mut self, v: BftSign) {
        self.view_change_msg = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_view_change_msg(&mut self) -> &mut BftSign {
        if self.view_change_msg.is_none() {
            self.view_change_msg.set_default();
        }
        self.view_change_msg.as_mut().unwrap()
    }

    // Take field
    pub fn take_view_change_msg(&mut self) -> BftSign {
        self.view_change_msg.take().unwrap_or_else(|| BftSign::new())
    }

    // .BftSign new_view = 10;


    pub fn get_new_view(&self) -> &BftSign {
        self.new_view.as_ref().unwrap_or_else(|| <BftSign as ::protobuf::Message>::default_instance())
    }
    pub fn clear_new_view(&mut self) {
        self.new_view.clear();
    }

    pub fn has_new_view(&self) -> bool {
        self.new_view.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_view(&mut self, v: BftSign) {
        self.new_view = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_new_view(&mut self) -> &mut BftSign {
        if self.new_view.is_none() {
            self.new_view.set_default();
        }
        self.new_view.as_mut().unwrap()
    }

    // Take field
    pub fn take_new_view(&mut self) -> BftSign {
        self.new_view.take().unwrap_or_else(|| BftSign::new())
    }

    // repeated .BftSign msg_buffer = 11;


    pub fn get_msg_buffer(&self) -> &[BftSign] {
        &self.msg_buffer
    }
    pub fn clear_msg_buffer(&mut self) {
        self.msg_buffer.clear();
    }

    // Param is passed by value, moved
    pub fn set_msg_buffer(&mut self, v: ::protobuf::RepeatedField<BftSign>) {
        self.msg_buffer = v;
    }

    // Mutable pointer to the field.
    pub fn mut_msg_buffer(&mut self) -> &mut ::protobuf::RepeatedField<BftSign> {
        &mut self.msg_buffer
    }

    // Take field
    pub fn take_msg_buffer(&mut self) -> ::protobuf::RepeatedField<BftSign> {
        ::std::mem::replace(&mut self.msg_buffer, ::protobuf::RepeatedField::new())
    }

    // repeated .BftViewChange view_changes = 12;


    pub fn get_view_changes(&self) -> &[BftViewChange] {
        &self.view_changes
    }
    pub fn clear_view_changes(&mut self) {
        self.view_changes.clear();
    }

    // Param is passed by value, moved
    pub fn set_view_changes(&mut self, v: ::protobuf::RepeatedField<BftViewChange>) {
        self.view_changes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_view_changes(&mut self) -> &mut ::protobuf::RepeatedField<BftViewChange> {
        &mut self.view_changes
    }

    // Take field
    pub fn take_view_changes(&mut self) -> ::protobuf::RepeatedField<BftViewChange> {
        ::std::mem::replace(&mut self.view_changes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ViewChangeStore {
    fn is_initialized(&self) -> bool {
        for v in &self.view_change_msg {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.new_view {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.msg_buffer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.view_changes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sequence = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.view_number = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.view_change_round = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_time = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.end_time = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.last_propose_time = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.last_newview_time = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.new_view_round = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.view_change_msg)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.new_view)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.msg_buffer)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.view_changes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.sequence != 0 {
            my_size += ::protobuf::rt::value_size(1, self.sequence, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.view_number != 0 {
            my_size += ::protobuf::rt::value_size(2, self.view_number, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.view_change_round != 0 {
            my_size += ::protobuf::rt::value_size(3, self.view_change_round, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.start_time != 0 {
            my_size += ::protobuf::rt::value_size(4, self.start_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.end_time != 0 {
            my_size += ::protobuf::rt::value_size(5, self.end_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.last_propose_time != 0 {
            my_size += ::protobuf::rt::value_size(6, self.last_propose_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.last_newview_time != 0 {
            my_size += ::protobuf::rt::value_size(7, self.last_newview_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.new_view_round != 0 {
            my_size += ::protobuf::rt::value_size(8, self.new_view_round, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.view_change_msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.new_view.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.msg_buffer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.view_changes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.sequence != 0 {
            os.write_uint64(1, self.sequence)?;
        }
        if self.view_number != 0 {
            os.write_int64(2, self.view_number)?;
        }
        if self.view_change_round != 0 {
            os.write_uint64(3, self.view_change_round)?;
        }
        if self.start_time != 0 {
            os.write_uint64(4, self.start_time)?;
        }
        if self.end_time != 0 {
            os.write_uint64(5, self.end_time)?;
        }
        if self.last_propose_time != 0 {
            os.write_uint64(6, self.last_propose_time)?;
        }
        if self.last_newview_time != 0 {
            os.write_uint64(7, self.last_newview_time)?;
        }
        if self.new_view_round != 0 {
            os.write_uint64(8, self.new_view_round)?;
        }
        if let Some(ref v) = self.view_change_msg.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.new_view.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.msg_buffer {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.view_changes {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ViewChangeStore {
        ViewChangeStore::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "sequence",
                |m: &ViewChangeStore| { &m.sequence },
                |m: &mut ViewChangeStore| { &mut m.sequence },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "view_number",
                |m: &ViewChangeStore| { &m.view_number },
                |m: &mut ViewChangeStore| { &mut m.view_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "view_change_round",
                |m: &ViewChangeStore| { &m.view_change_round },
                |m: &mut ViewChangeStore| { &mut m.view_change_round },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "start_time",
                |m: &ViewChangeStore| { &m.start_time },
                |m: &mut ViewChangeStore| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "end_time",
                |m: &ViewChangeStore| { &m.end_time },
                |m: &mut ViewChangeStore| { &mut m.end_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "last_propose_time",
                |m: &ViewChangeStore| { &m.last_propose_time },
                |m: &mut ViewChangeStore| { &mut m.last_propose_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "last_newview_time",
                |m: &ViewChangeStore| { &m.last_newview_time },
                |m: &mut ViewChangeStore| { &mut m.last_newview_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "new_view_round",
                |m: &ViewChangeStore| { &m.new_view_round },
                |m: &mut ViewChangeStore| { &mut m.new_view_round },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BftSign>>(
                "view_change_msg",
                |m: &ViewChangeStore| { &m.view_change_msg },
                |m: &mut ViewChangeStore| { &mut m.view_change_msg },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BftSign>>(
                "new_view",
                |m: &ViewChangeStore| { &m.new_view },
                |m: &mut ViewChangeStore| { &mut m.new_view },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BftSign>>(
                "msg_buffer",
                |m: &ViewChangeStore| { &m.msg_buffer },
                |m: &mut ViewChangeStore| { &mut m.msg_buffer },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BftViewChange>>(
                "view_changes",
                |m: &ViewChangeStore| { &m.view_changes },
                |m: &mut ViewChangeStore| { &mut m.view_changes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ViewChangeStore>(
                "ViewChangeStore",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ViewChangeStore {
        static instance: ::protobuf::rt::LazyV2<ViewChangeStore> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ViewChangeStore::new)
    }
}

impl ::protobuf::Clear for ViewChangeStore {
    fn clear(&mut self) {
        self.sequence = 0;
        self.view_number = 0;
        self.view_change_round = 0;
        self.start_time = 0;
        self.end_time = 0;
        self.last_propose_time = 0;
        self.last_newview_time = 0;
        self.new_view_round = 0;
        self.view_change_msg.clear();
        self.new_view.clear();
        self.msg_buffer.clear();
        self.view_changes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ViewChangeStore {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ViewChangeStore {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ViewChangeMessage {
    // message fields
    pub item: ::protobuf::RepeatedField<ViewChangeStore>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ViewChangeMessage {
    fn default() -> &'a ViewChangeMessage {
        <ViewChangeMessage as ::protobuf::Message>::default_instance()
    }
}

impl ViewChangeMessage {
    pub fn new() -> ViewChangeMessage {
        ::std::default::Default::default()
    }

    // repeated .ViewChangeStore item = 1;


    pub fn get_item(&self) -> &[ViewChangeStore] {
        &self.item
    }
    pub fn clear_item(&mut self) {
        self.item.clear();
    }

    // Param is passed by value, moved
    pub fn set_item(&mut self, v: ::protobuf::RepeatedField<ViewChangeStore>) {
        self.item = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item(&mut self) -> &mut ::protobuf::RepeatedField<ViewChangeStore> {
        &mut self.item
    }

    // Take field
    pub fn take_item(&mut self) -> ::protobuf::RepeatedField<ViewChangeStore> {
        ::std::mem::replace(&mut self.item, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ViewChangeMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.item {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.item)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.item {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.item {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ViewChangeMessage {
        ViewChangeMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ViewChangeStore>>(
                "item",
                |m: &ViewChangeMessage| { &m.item },
                |m: &mut ViewChangeMessage| { &mut m.item },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ViewChangeMessage>(
                "ViewChangeMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ViewChangeMessage {
        static instance: ::protobuf::rt::LazyV2<ViewChangeMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ViewChangeMessage::new)
    }
}

impl ::protobuf::Clear for ViewChangeMessage {
    fn clear(&mut self) {
        self.item.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ViewChangeMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ViewChangeMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NewViewRepondParam {
    // message fields
    pub view_number: i64,
    pub prepared_set: ::protobuf::SingularPtrField<BftPreparedSet>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NewViewRepondParam {
    fn default() -> &'a NewViewRepondParam {
        <NewViewRepondParam as ::protobuf::Message>::default_instance()
    }
}

impl NewViewRepondParam {
    pub fn new() -> NewViewRepondParam {
        ::std::default::Default::default()
    }

    // int64 view_number = 1;


    pub fn get_view_number(&self) -> i64 {
        self.view_number
    }
    pub fn clear_view_number(&mut self) {
        self.view_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_view_number(&mut self, v: i64) {
        self.view_number = v;
    }

    // .BftPreparedSet prepared_set = 2;


    pub fn get_prepared_set(&self) -> &BftPreparedSet {
        self.prepared_set.as_ref().unwrap_or_else(|| <BftPreparedSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_prepared_set(&mut self) {
        self.prepared_set.clear();
    }

    pub fn has_prepared_set(&self) -> bool {
        self.prepared_set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prepared_set(&mut self, v: BftPreparedSet) {
        self.prepared_set = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prepared_set(&mut self) -> &mut BftPreparedSet {
        if self.prepared_set.is_none() {
            self.prepared_set.set_default();
        }
        self.prepared_set.as_mut().unwrap()
    }

    // Take field
    pub fn take_prepared_set(&mut self) -> BftPreparedSet {
        self.prepared_set.take().unwrap_or_else(|| BftPreparedSet::new())
    }
}

impl ::protobuf::Message for NewViewRepondParam {
    fn is_initialized(&self) -> bool {
        for v in &self.prepared_set {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.view_number = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.prepared_set)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.view_number != 0 {
            my_size += ::protobuf::rt::value_size(1, self.view_number, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.prepared_set.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.view_number != 0 {
            os.write_int64(1, self.view_number)?;
        }
        if let Some(ref v) = self.prepared_set.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NewViewRepondParam {
        NewViewRepondParam::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "view_number",
                |m: &NewViewRepondParam| { &m.view_number },
                |m: &mut NewViewRepondParam| { &mut m.view_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BftPreparedSet>>(
                "prepared_set",
                |m: &NewViewRepondParam| { &m.prepared_set },
                |m: &mut NewViewRepondParam| { &mut m.prepared_set },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NewViewRepondParam>(
                "NewViewRepondParam",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NewViewRepondParam {
        static instance: ::protobuf::rt::LazyV2<NewViewRepondParam> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NewViewRepondParam::new)
    }
}

impl ::protobuf::Clear for NewViewRepondParam {
    fn clear(&mut self) {
        self.view_number = 0;
        self.prepared_set.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NewViewRepondParam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NewViewRepondParam {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LedgerUpgrade {
    // message fields
    pub new_version: u64,
    pub chain_id: ::std::string::String,
    pub chain_hub: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LedgerUpgrade {
    fn default() -> &'a LedgerUpgrade {
        <LedgerUpgrade as ::protobuf::Message>::default_instance()
    }
}

impl LedgerUpgrade {
    pub fn new() -> LedgerUpgrade {
        ::std::default::Default::default()
    }

    // uint64 new_version = 1;


    pub fn get_new_version(&self) -> u64 {
        self.new_version
    }
    pub fn clear_new_version(&mut self) {
        self.new_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_new_version(&mut self, v: u64) {
        self.new_version = v;
    }

    // string chain_id = 2;


    pub fn get_chain_id(&self) -> &str {
        &self.chain_id
    }
    pub fn clear_chain_id(&mut self) {
        self.chain_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_chain_id(&mut self, v: ::std::string::String) {
        self.chain_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chain_id(&mut self) -> &mut ::std::string::String {
        &mut self.chain_id
    }

    // Take field
    pub fn take_chain_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.chain_id, ::std::string::String::new())
    }

    // string chain_hub = 3;


    pub fn get_chain_hub(&self) -> &str {
        &self.chain_hub
    }
    pub fn clear_chain_hub(&mut self) {
        self.chain_hub.clear();
    }

    // Param is passed by value, moved
    pub fn set_chain_hub(&mut self, v: ::std::string::String) {
        self.chain_hub = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chain_hub(&mut self) -> &mut ::std::string::String {
        &mut self.chain_hub
    }

    // Take field
    pub fn take_chain_hub(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.chain_hub, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LedgerUpgrade {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.new_version = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.chain_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.chain_hub)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.new_version != 0 {
            my_size += ::protobuf::rt::value_size(1, self.new_version, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.chain_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.chain_id);
        }
        if !self.chain_hub.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.chain_hub);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.new_version != 0 {
            os.write_uint64(1, self.new_version)?;
        }
        if !self.chain_id.is_empty() {
            os.write_string(2, &self.chain_id)?;
        }
        if !self.chain_hub.is_empty() {
            os.write_string(3, &self.chain_hub)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LedgerUpgrade {
        LedgerUpgrade::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "new_version",
                |m: &LedgerUpgrade| { &m.new_version },
                |m: &mut LedgerUpgrade| { &mut m.new_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "chain_id",
                |m: &LedgerUpgrade| { &m.chain_id },
                |m: &mut LedgerUpgrade| { &mut m.chain_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "chain_hub",
                |m: &LedgerUpgrade| { &m.chain_hub },
                |m: &mut LedgerUpgrade| { &mut m.chain_hub },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LedgerUpgrade>(
                "LedgerUpgrade",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LedgerUpgrade {
        static instance: ::protobuf::rt::LazyV2<LedgerUpgrade> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LedgerUpgrade::new)
    }
}

impl ::protobuf::Clear for LedgerUpgrade {
    fn clear(&mut self) {
        self.new_version = 0;
        self.chain_id.clear();
        self.chain_hub.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LedgerUpgrade {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LedgerUpgrade {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LedgerUpgradeNotify {
    // message fields
    pub nonce: i64,
    pub upgrade: ::protobuf::SingularPtrField<LedgerUpgrade>,
    pub signature: ::protobuf::SingularPtrField<super::common::Signature>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LedgerUpgradeNotify {
    fn default() -> &'a LedgerUpgradeNotify {
        <LedgerUpgradeNotify as ::protobuf::Message>::default_instance()
    }
}

impl LedgerUpgradeNotify {
    pub fn new() -> LedgerUpgradeNotify {
        ::std::default::Default::default()
    }

    // int64 nonce = 1;


    pub fn get_nonce(&self) -> i64 {
        self.nonce
    }
    pub fn clear_nonce(&mut self) {
        self.nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: i64) {
        self.nonce = v;
    }

    // .LedgerUpgrade upgrade = 2;


    pub fn get_upgrade(&self) -> &LedgerUpgrade {
        self.upgrade.as_ref().unwrap_or_else(|| <LedgerUpgrade as ::protobuf::Message>::default_instance())
    }
    pub fn clear_upgrade(&mut self) {
        self.upgrade.clear();
    }

    pub fn has_upgrade(&self) -> bool {
        self.upgrade.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upgrade(&mut self, v: LedgerUpgrade) {
        self.upgrade = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_upgrade(&mut self) -> &mut LedgerUpgrade {
        if self.upgrade.is_none() {
            self.upgrade.set_default();
        }
        self.upgrade.as_mut().unwrap()
    }

    // Take field
    pub fn take_upgrade(&mut self) -> LedgerUpgrade {
        self.upgrade.take().unwrap_or_else(|| LedgerUpgrade::new())
    }

    // .Signature signature = 3;


    pub fn get_signature(&self) -> &super::common::Signature {
        self.signature.as_ref().unwrap_or_else(|| <super::common::Signature as ::protobuf::Message>::default_instance())
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: super::common::Signature) {
        self.signature = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut super::common::Signature {
        if self.signature.is_none() {
            self.signature.set_default();
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> super::common::Signature {
        self.signature.take().unwrap_or_else(|| super::common::Signature::new())
    }
}

impl ::protobuf::Message for LedgerUpgradeNotify {
    fn is_initialized(&self) -> bool {
        for v in &self.upgrade {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.signature {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.nonce = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.upgrade)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.nonce != 0 {
            my_size += ::protobuf::rt::value_size(1, self.nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.upgrade.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.signature.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.nonce != 0 {
            os.write_int64(1, self.nonce)?;
        }
        if let Some(ref v) = self.upgrade.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.signature.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LedgerUpgradeNotify {
        LedgerUpgradeNotify::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "nonce",
                |m: &LedgerUpgradeNotify| { &m.nonce },
                |m: &mut LedgerUpgradeNotify| { &mut m.nonce },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LedgerUpgrade>>(
                "upgrade",
                |m: &LedgerUpgradeNotify| { &m.upgrade },
                |m: &mut LedgerUpgradeNotify| { &mut m.upgrade },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Signature>>(
                "signature",
                |m: &LedgerUpgradeNotify| { &m.signature },
                |m: &mut LedgerUpgradeNotify| { &mut m.signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LedgerUpgradeNotify>(
                "LedgerUpgradeNotify",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LedgerUpgradeNotify {
        static instance: ::protobuf::rt::LazyV2<LedgerUpgradeNotify> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LedgerUpgradeNotify::new)
    }
}

impl ::protobuf::Clear for LedgerUpgradeNotify {
    fn clear(&mut self) {
        self.nonce = 0;
        self.upgrade.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LedgerUpgradeNotify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LedgerUpgradeNotify {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LedgerUpgradeInfo {
    // message fields
    pub recv_time: i64,
    pub address: ::std::string::String,
    pub msg: ::protobuf::SingularPtrField<LedgerUpgradeNotify>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LedgerUpgradeInfo {
    fn default() -> &'a LedgerUpgradeInfo {
        <LedgerUpgradeInfo as ::protobuf::Message>::default_instance()
    }
}

impl LedgerUpgradeInfo {
    pub fn new() -> LedgerUpgradeInfo {
        ::std::default::Default::default()
    }

    // int64 recv_time = 1;


    pub fn get_recv_time(&self) -> i64 {
        self.recv_time
    }
    pub fn clear_recv_time(&mut self) {
        self.recv_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_recv_time(&mut self, v: i64) {
        self.recv_time = v;
    }

    // string address = 2;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // .LedgerUpgradeNotify msg = 3;


    pub fn get_msg(&self) -> &LedgerUpgradeNotify {
        self.msg.as_ref().unwrap_or_else(|| <LedgerUpgradeNotify as ::protobuf::Message>::default_instance())
    }
    pub fn clear_msg(&mut self) {
        self.msg.clear();
    }

    pub fn has_msg(&self) -> bool {
        self.msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg(&mut self, v: LedgerUpgradeNotify) {
        self.msg = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg(&mut self) -> &mut LedgerUpgradeNotify {
        if self.msg.is_none() {
            self.msg.set_default();
        }
        self.msg.as_mut().unwrap()
    }

    // Take field
    pub fn take_msg(&mut self) -> LedgerUpgradeNotify {
        self.msg.take().unwrap_or_else(|| LedgerUpgradeNotify::new())
    }
}

impl ::protobuf::Message for LedgerUpgradeInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.msg {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.recv_time = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.msg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.recv_time != 0 {
            my_size += ::protobuf::rt::value_size(1, self.recv_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.address);
        }
        if let Some(ref v) = self.msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.recv_time != 0 {
            os.write_int64(1, self.recv_time)?;
        }
        if !self.address.is_empty() {
            os.write_string(2, &self.address)?;
        }
        if let Some(ref v) = self.msg.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LedgerUpgradeInfo {
        LedgerUpgradeInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "recv_time",
                |m: &LedgerUpgradeInfo| { &m.recv_time },
                |m: &mut LedgerUpgradeInfo| { &mut m.recv_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &LedgerUpgradeInfo| { &m.address },
                |m: &mut LedgerUpgradeInfo| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LedgerUpgradeNotify>>(
                "msg",
                |m: &LedgerUpgradeInfo| { &m.msg },
                |m: &mut LedgerUpgradeInfo| { &mut m.msg },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LedgerUpgradeInfo>(
                "LedgerUpgradeInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LedgerUpgradeInfo {
        static instance: ::protobuf::rt::LazyV2<LedgerUpgradeInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LedgerUpgradeInfo::new)
    }
}

impl ::protobuf::Clear for LedgerUpgradeInfo {
    fn clear(&mut self) {
        self.recv_time = 0;
        self.address.clear();
        self.msg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LedgerUpgradeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LedgerUpgradeInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ConsensusType {
    PBFT = 0,
}

impl ::protobuf::ProtobufEnum for ConsensusType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ConsensusType> {
        match value {
            0 => ::std::option::Option::Some(ConsensusType::PBFT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ConsensusType] = &[
            ConsensusType::PBFT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ConsensusType>("ConsensusType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ConsensusType {
}

impl ::std::default::Default for ConsensusType {
    fn default() -> Self {
        ConsensusType::PBFT
    }
}

impl ::protobuf::reflect::ProtobufValue for ConsensusType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BftMessageType {
    PRE_PREPARE = 0,
    PREPARE = 1,
    COMMIT = 2,
    VIEW_CHANGE = 3,
    NEW_VIEW = 4,
    VIEW_CHANGE_VALUE = 5,
}

impl ::protobuf::ProtobufEnum for BftMessageType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BftMessageType> {
        match value {
            0 => ::std::option::Option::Some(BftMessageType::PRE_PREPARE),
            1 => ::std::option::Option::Some(BftMessageType::PREPARE),
            2 => ::std::option::Option::Some(BftMessageType::COMMIT),
            3 => ::std::option::Option::Some(BftMessageType::VIEW_CHANGE),
            4 => ::std::option::Option::Some(BftMessageType::NEW_VIEW),
            5 => ::std::option::Option::Some(BftMessageType::VIEW_CHANGE_VALUE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BftMessageType] = &[
            BftMessageType::PRE_PREPARE,
            BftMessageType::PREPARE,
            BftMessageType::COMMIT,
            BftMessageType::VIEW_CHANGE,
            BftMessageType::NEW_VIEW,
            BftMessageType::VIEW_CHANGE_VALUE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<BftMessageType>("BftMessageType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for BftMessageType {
}

impl ::std::default::Default for BftMessageType {
    fn default() -> Self {
        BftMessageType::PRE_PREPARE
    }
}

impl ::protobuf::reflect::ProtobufValue for BftMessageType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0fconsensus.proto\x1a\x0ccommon.proto\"Z\n\tConsensus\x127\n\x0econs\
    ensus_type\x18\x01\x20\x01(\x0e2\x0e.ConsensusTypeR\rconsensusTypeB\0\
    \x12\x12\n\x03msg\x18\x02\x20\x01(\x0cR\x03msgB\0:\0\"c\n\x0eConsensusPr\
    oof\x127\n\x0econsensus_type\x18\x01\x20\x01(\x0e2\x0e.ConsensusTypeR\rc\
    onsensusTypeB\0\x12\x16\n\x05proof\x18\x02\x20\x01(\x0cR\x05proofB\0:\0\
    \"q\n\x0bBftBaseInfo\x12!\n\x0bview_number\x18\x01\x20\x01(\x03R\nviewNu\
    mberB\0\x12\x1c\n\x08sequence\x18\x02\x20\x01(\x04R\x08sequenceB\0\x12\
    \x1f\n\nreplica_id\x18\x03\x20\x01(\x03R\treplicaIdB\0:\0\"r\n\rBftPrePr\
    epare\x12\"\n\x04base\x18\x01\x20\x01(\x0b2\x0c.BftBaseInfoR\x04baseB\0\
    \x12\x16\n\x05value\x18\x02\x20\x01(\x0cR\x05valueB\0\x12#\n\x0cvalue_di\
    gest\x18\x03\x20\x01(\x0cR\x0bvalueDigestB\0:\0\"W\n\nBftPrepare\x12\"\n\
    \x04base\x18\x01\x20\x01(\x0b2\x0c.BftBaseInfoR\x04baseB\0\x12#\n\x0cval\
    ue_digest\x18\x02\x20\x01(\x0cR\x0bvalueDigestB\0:\0\"V\n\tBftCommit\x12\
    \"\n\x04base\x18\x01\x20\x01(\x0b2\x0c.BftBaseInfoR\x04baseB\0\x12#\n\
    \x0cvalue_digest\x18\x02\x20\x01(\x0cR\x0bvalueDigestB\0:\0\"e\n\x0eBftP\
    reparedSet\x12+\n\x0bpre_prepare\x18\x01\x20\x01(\x0b2\x08.BftSignR\npre\
    PrepareB\0\x12$\n\x07prepare\x18\x02\x20\x03(\x0b2\x08.BftSignR\x07prepa\
    reB\0:\0\"k\n\rBftViewChange\x12\"\n\x04base\x18\x01\x20\x01(\x0b2\x0c.B\
    ftBaseInfoR\x04baseB\0\x124\n\x15prepared_value_digest\x18\x02\x20\x01(\
    \x0cR\x13preparedValueDigestB\0:\0\"\x80\x01\n\x12BftViewChangeValue\x12\
    2\n\x0fview_change_env\x18\x01\x20\x01(\x0b2\x08.BftSignR\rviewChangeEnv\
    B\0\x124\n\x0cprepared_set\x18\x02\x20\x01(\x0b2\x0f.BftPreparedSetR\x0b\
    preparedSetB\0:\0\"\x8e\x01\n\nBftNewView\x12\"\n\x04base\x18\x01\x20\
    \x01(\x0b2\x0c.BftBaseInfoR\x04baseB\0\x12-\n\x0cview_changes\x18\x02\
    \x20\x03(\x0b2\x08.BftSignR\x0bviewChangesB\0\x12+\n\x0bpre_prepare\x18\
    \x03\x20\x01(\x0b2\x08.BftSignR\nprePrepareB\0:\0\"\xfc\x02\n\x03Bft\x12\
    #\n\x0cround_number\x18\x01\x20\x01(\x04R\x0broundNumberB\0\x12,\n\x08ms\
    g_type\x18\x02\x20\x01(\x0e2\x0f.BftMessageTypeR\x07msgTypeB\0\x121\n\
    \x0bpre_prepare\x18\x03\x20\x01(\x0b2\x0e.BftPrePrepareR\nprePrepareB\0\
    \x12'\n\x07prepare\x18\x04\x20\x01(\x0b2\x0b.BftPrepareR\x07prepareB\0\
    \x12$\n\x06commit\x18\x05\x20\x01(\x0b2\n.BftCommitR\x06commitB\0\x121\n\
    \x0bview_change\x18\x06\x20\x01(\x0b2\x0e.BftViewChangeR\nviewChangeB\0\
    \x12(\n\x08new_view\x18\x07\x20\x01(\x0b2\x0b.BftNewViewR\x07newViewB\0\
    \x12A\n\x11view_change_value\x18\x08\x20\x01(\x0b2\x13.BftViewChangeValu\
    eR\x0fviewChangeValueB\0:\0\"\x8d\x01\n\x07BftSign\x12\x18\n\x03bft\x18\
    \x01\x20\x01(\x0b2\x04.BftR\x03bftB\0\x12*\n\tsignature\x18\x02\x20\x01(\
    \x0b2\n.SignatureR\tsignatureB\0\x12\x1b\n\x08chain_id\x18\x03\x20\x01(\
    \tR\x07chainIdB\0\x12\x1d\n\tchain_hub\x18\x04\x20\x01(\tR\x08chainHubB\
    \0:\0\"2\n\x08BftProof\x12$\n\x07commits\x18\x01\x20\x03(\x0b2\x08.BftSi\
    gnR\x07commitsB\0:\0\"+\n\nTxHashList\x12\x1b\n\x08hash_set\x18\x01\x20\
    \x03(\x0cR\x07hashSetB\0:\0\"\xff\x03\n\x0fViewChangeStore\x12\x1c\n\x08\
    sequence\x18\x01\x20\x01(\x04R\x08sequenceB\0\x12!\n\x0bview_number\x18\
    \x02\x20\x01(\x03R\nviewNumberB\0\x12,\n\x11view_change_round\x18\x03\
    \x20\x01(\x04R\x0fviewChangeRoundB\0\x12\x1f\n\nstart_time\x18\x04\x20\
    \x01(\x04R\tstartTimeB\0\x12\x1b\n\x08end_time\x18\x05\x20\x01(\x04R\x07\
    endTimeB\0\x12,\n\x11last_propose_time\x18\x06\x20\x01(\x04R\x0flastProp\
    oseTimeB\0\x12,\n\x11last_newview_time\x18\x07\x20\x01(\x04R\x0flastNewv\
    iewTimeB\0\x12&\n\x0enew_view_round\x18\x08\x20\x01(\x04R\x0cnewViewRoun\
    dB\0\x122\n\x0fview_change_msg\x18\t\x20\x01(\x0b2\x08.BftSignR\rviewCha\
    ngeMsgB\0\x12%\n\x08new_view\x18\n\x20\x01(\x0b2\x08.BftSignR\x07newView\
    B\0\x12)\n\nmsg_buffer\x18\x0b\x20\x03(\x0b2\x08.BftSignR\tmsgBufferB\0\
    \x123\n\x0cview_changes\x18\x0c\x20\x03(\x0b2\x0e.BftViewChangeR\x0bview\
    ChangesB\0:\0\"=\n\x11ViewChangeMessage\x12&\n\x04item\x18\x01\x20\x03(\
    \x0b2\x10.ViewChangeStoreR\x04itemB\0:\0\"o\n\x12NewViewRepondParam\x12!\
    \n\x0bview_number\x18\x01\x20\x01(\x03R\nviewNumberB\0\x124\n\x0cprepare\
    d_set\x18\x02\x20\x01(\x0b2\x0f.BftPreparedSetR\x0bpreparedSetB\0:\0\"p\
    \n\rLedgerUpgrade\x12!\n\x0bnew_version\x18\x01\x20\x01(\x04R\nnewVersio\
    nB\0\x12\x1b\n\x08chain_id\x18\x02\x20\x01(\tR\x07chainIdB\0\x12\x1d\n\t\
    chain_hub\x18\x03\x20\x01(\tR\x08chainHubB\0:\0\"\x87\x01\n\x13LedgerUpg\
    radeNotify\x12\x16\n\x05nonce\x18\x01\x20\x01(\x03R\x05nonceB\0\x12*\n\
    \x07upgrade\x18\x02\x20\x01(\x0b2\x0e.LedgerUpgradeR\x07upgradeB\0\x12*\
    \n\tsignature\x18\x03\x20\x01(\x0b2\n.SignatureR\tsignatureB\0:\0\"z\n\
    \x11LedgerUpgradeInfo\x12\x1d\n\trecv_time\x18\x01\x20\x01(\x03R\x08recv\
    TimeB\0\x12\x1a\n\x07address\x18\x02\x20\x01(\tR\x07addressB\0\x12(\n\
    \x03msg\x18\x03\x20\x01(\x0b2\x14.LedgerUpgradeNotifyR\x03msgB\0:\0*\x1b\
    \n\rConsensusType\x12\x08\n\x04PBFT\x10\0\x1a\0*r\n\x0eBftMessageType\
    \x12\x0f\n\x0bPRE_PREPARE\x10\0\x12\x0b\n\x07PREPARE\x10\x01\x12\n\n\x06\
    COMMIT\x10\x02\x12\x0f\n\x0bVIEW_CHANGE\x10\x03\x12\x0c\n\x08NEW_VIEW\
    \x10\x04\x12\x15\n\x11VIEW_CHANGE_VALUE\x10\x05\x1a\0B\0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
