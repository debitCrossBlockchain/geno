// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `common.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct ProtocolsMessage {
    // message fields
    pub msg_type: ProtocolsMessageType,
    pub action: ProtocolsActionMessageType,
    pub sequence: u64,
    pub data: ::std::vec::Vec<u8>,
    pub timestamp: i64,
    pub route: ::protobuf::RepeatedField<::std::string::String>,
    pub hash: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProtocolsMessage {
    fn default() -> &'a ProtocolsMessage {
        <ProtocolsMessage as ::protobuf::Message>::default_instance()
    }
}

impl ProtocolsMessage {
    pub fn new() -> ProtocolsMessage {
        ::std::default::Default::default()
    }

    // .ProtocolsMessageType msg_type = 1;


    pub fn get_msg_type(&self) -> ProtocolsMessageType {
        self.msg_type
    }
    pub fn clear_msg_type(&mut self) {
        self.msg_type = ProtocolsMessageType::NONE;
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: ProtocolsMessageType) {
        self.msg_type = v;
    }

    // .ProtocolsActionMessageType action = 2;


    pub fn get_action(&self) -> ProtocolsActionMessageType {
        self.action
    }
    pub fn clear_action(&mut self) {
        self.action = ProtocolsActionMessageType::BROADCAST;
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ProtocolsActionMessageType) {
        self.action = v;
    }

    // uint64 sequence = 3;


    pub fn get_sequence(&self) -> u64 {
        self.sequence
    }
    pub fn clear_sequence(&mut self) {
        self.sequence = 0;
    }

    // Param is passed by value, moved
    pub fn set_sequence(&mut self, v: u64) {
        self.sequence = v;
    }

    // bytes data = 4;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // int64 timestamp = 5;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // repeated string route = 6;


    pub fn get_route(&self) -> &[::std::string::String] {
        &self.route
    }
    pub fn clear_route(&mut self) {
        self.route.clear();
    }

    // Param is passed by value, moved
    pub fn set_route(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.route = v;
    }

    // Mutable pointer to the field.
    pub fn mut_route(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.route
    }

    // Take field
    pub fn take_route(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.route, ::protobuf::RepeatedField::new())
    }

    // string hash = 7;


    pub fn get_hash(&self) -> &str {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::string::String) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::string::String {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hash, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ProtocolsMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.msg_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sequence = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.route)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.msg_type != ProtocolsMessageType::NONE {
            my_size += ::protobuf::rt::enum_size(1, self.msg_type);
        }
        if self.action != ProtocolsActionMessageType::BROADCAST {
            my_size += ::protobuf::rt::enum_size(2, self.action);
        }
        if self.sequence != 0 {
            my_size += ::protobuf::rt::value_size(3, self.sequence, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.data);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(5, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.route {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.msg_type != ProtocolsMessageType::NONE {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.msg_type))?;
        }
        if self.action != ProtocolsActionMessageType::BROADCAST {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.action))?;
        }
        if self.sequence != 0 {
            os.write_uint64(3, self.sequence)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(4, &self.data)?;
        }
        if self.timestamp != 0 {
            os.write_int64(5, self.timestamp)?;
        }
        for v in &self.route {
            os.write_string(6, &v)?;
        };
        if !self.hash.is_empty() {
            os.write_string(7, &self.hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProtocolsMessage {
        ProtocolsMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ProtocolsMessageType>>(
                "msg_type",
                |m: &ProtocolsMessage| { &m.msg_type },
                |m: &mut ProtocolsMessage| { &mut m.msg_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ProtocolsActionMessageType>>(
                "action",
                |m: &ProtocolsMessage| { &m.action },
                |m: &mut ProtocolsMessage| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "sequence",
                |m: &ProtocolsMessage| { &m.sequence },
                |m: &mut ProtocolsMessage| { &mut m.sequence },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &ProtocolsMessage| { &m.data },
                |m: &mut ProtocolsMessage| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp",
                |m: &ProtocolsMessage| { &m.timestamp },
                |m: &mut ProtocolsMessage| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "route",
                |m: &ProtocolsMessage| { &m.route },
                |m: &mut ProtocolsMessage| { &mut m.route },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hash",
                |m: &ProtocolsMessage| { &m.hash },
                |m: &mut ProtocolsMessage| { &mut m.hash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProtocolsMessage>(
                "ProtocolsMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProtocolsMessage {
        static instance: ::protobuf::rt::LazyV2<ProtocolsMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProtocolsMessage::new)
    }
}

impl ::protobuf::Clear for ProtocolsMessage {
    fn clear(&mut self) {
        self.msg_type = ProtocolsMessageType::NONE;
        self.action = ProtocolsActionMessageType::BROADCAST;
        self.sequence = 0;
        self.data.clear();
        self.timestamp = 0;
        self.route.clear();
        self.hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProtocolsMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtocolsMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Ping {
    // message fields
    pub nonce: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Ping {
    fn default() -> &'a Ping {
        <Ping as ::protobuf::Message>::default_instance()
    }
}

impl Ping {
    pub fn new() -> Ping {
        ::std::default::Default::default()
    }

    // int64 nonce = 1;


    pub fn get_nonce(&self) -> i64 {
        self.nonce
    }
    pub fn clear_nonce(&mut self) {
        self.nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: i64) {
        self.nonce = v;
    }
}

impl ::protobuf::Message for Ping {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.nonce = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.nonce != 0 {
            my_size += ::protobuf::rt::value_size(1, self.nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.nonce != 0 {
            os.write_int64(1, self.nonce)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Ping {
        Ping::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "nonce",
                |m: &Ping| { &m.nonce },
                |m: &mut Ping| { &mut m.nonce },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Ping>(
                "Ping",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Ping {
        static instance: ::protobuf::rt::LazyV2<Ping> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Ping::new)
    }
}

impl ::protobuf::Clear for Ping {
    fn clear(&mut self) {
        self.nonce = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Ping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ping {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Pong {
    // message fields
    pub nonce: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Pong {
    fn default() -> &'a Pong {
        <Pong as ::protobuf::Message>::default_instance()
    }
}

impl Pong {
    pub fn new() -> Pong {
        ::std::default::Default::default()
    }

    // int64 nonce = 1;


    pub fn get_nonce(&self) -> i64 {
        self.nonce
    }
    pub fn clear_nonce(&mut self) {
        self.nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: i64) {
        self.nonce = v;
    }
}

impl ::protobuf::Message for Pong {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.nonce = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.nonce != 0 {
            my_size += ::protobuf::rt::value_size(1, self.nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.nonce != 0 {
            os.write_int64(1, self.nonce)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pong {
        Pong::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "nonce",
                |m: &Pong| { &m.nonce },
                |m: &mut Pong| { &mut m.nonce },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Pong>(
                "Pong",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Pong {
        static instance: ::protobuf::rt::LazyV2<Pong> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Pong::new)
    }
}

impl ::protobuf::Clear for Pong {
    fn clear(&mut self) {
        self.nonce = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Pong {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pong {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Peer {
    // message fields
    pub address: ::std::string::String,
    pub num_failures: i64,
    pub next_attempt_time: i64,
    pub active_time: i64,
    pub connection_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Peer {
    fn default() -> &'a Peer {
        <Peer as ::protobuf::Message>::default_instance()
    }
}

impl Peer {
    pub fn new() -> Peer {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // int64 num_failures = 2;


    pub fn get_num_failures(&self) -> i64 {
        self.num_failures
    }
    pub fn clear_num_failures(&mut self) {
        self.num_failures = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_failures(&mut self, v: i64) {
        self.num_failures = v;
    }

    // int64 next_attempt_time = 3;


    pub fn get_next_attempt_time(&self) -> i64 {
        self.next_attempt_time
    }
    pub fn clear_next_attempt_time(&mut self) {
        self.next_attempt_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_next_attempt_time(&mut self, v: i64) {
        self.next_attempt_time = v;
    }

    // int64 active_time = 4;


    pub fn get_active_time(&self) -> i64 {
        self.active_time
    }
    pub fn clear_active_time(&mut self) {
        self.active_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_active_time(&mut self, v: i64) {
        self.active_time = v;
    }

    // int64 connection_id = 5;


    pub fn get_connection_id(&self) -> i64 {
        self.connection_id
    }
    pub fn clear_connection_id(&mut self) {
        self.connection_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: i64) {
        self.connection_id = v;
    }
}

impl ::protobuf::Message for Peer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.num_failures = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.next_attempt_time = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.active_time = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.connection_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.num_failures != 0 {
            my_size += ::protobuf::rt::value_size(2, self.num_failures, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.next_attempt_time != 0 {
            my_size += ::protobuf::rt::value_size(3, self.next_attempt_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.active_time != 0 {
            my_size += ::protobuf::rt::value_size(4, self.active_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.connection_id != 0 {
            my_size += ::protobuf::rt::value_size(5, self.connection_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.num_failures != 0 {
            os.write_int64(2, self.num_failures)?;
        }
        if self.next_attempt_time != 0 {
            os.write_int64(3, self.next_attempt_time)?;
        }
        if self.active_time != 0 {
            os.write_int64(4, self.active_time)?;
        }
        if self.connection_id != 0 {
            os.write_int64(5, self.connection_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Peer {
        Peer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &Peer| { &m.address },
                |m: &mut Peer| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "num_failures",
                |m: &Peer| { &m.num_failures },
                |m: &mut Peer| { &mut m.num_failures },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "next_attempt_time",
                |m: &Peer| { &m.next_attempt_time },
                |m: &mut Peer| { &mut m.next_attempt_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "active_time",
                |m: &Peer| { &m.active_time },
                |m: &mut Peer| { &mut m.active_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "connection_id",
                |m: &Peer| { &m.connection_id },
                |m: &mut Peer| { &mut m.connection_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Peer>(
                "Peer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Peer {
        static instance: ::protobuf::rt::LazyV2<Peer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Peer::new)
    }
}

impl ::protobuf::Clear for Peer {
    fn clear(&mut self) {
        self.address.clear();
        self.num_failures = 0;
        self.next_attempt_time = 0;
        self.active_time = 0;
        self.connection_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Peer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Peer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Peers {
    // message fields
    pub peers: ::protobuf::RepeatedField<Peer>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Peers {
    fn default() -> &'a Peers {
        <Peers as ::protobuf::Message>::default_instance()
    }
}

impl Peers {
    pub fn new() -> Peers {
        ::std::default::Default::default()
    }

    // repeated .Peer peers = 1;


    pub fn get_peers(&self) -> &[Peer] {
        &self.peers
    }
    pub fn clear_peers(&mut self) {
        self.peers.clear();
    }

    // Param is passed by value, moved
    pub fn set_peers(&mut self, v: ::protobuf::RepeatedField<Peer>) {
        self.peers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peers(&mut self) -> &mut ::protobuf::RepeatedField<Peer> {
        &mut self.peers
    }

    // Take field
    pub fn take_peers(&mut self) -> ::protobuf::RepeatedField<Peer> {
        ::std::mem::replace(&mut self.peers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Peers {
    fn is_initialized(&self) -> bool {
        for v in &self.peers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.peers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.peers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.peers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Peers {
        Peers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Peer>>(
                "peers",
                |m: &Peers| { &m.peers },
                |m: &mut Peers| { &mut m.peers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Peers>(
                "Peers",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Peers {
        static instance: ::protobuf::rt::LazyV2<Peers> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Peers::new)
    }
}

impl ::protobuf::Clear for Peers {
    fn clear(&mut self) {
        self.peers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Peers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Peers {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyPair {
    // message fields
    pub key: ::std::vec::Vec<u8>,
    pub value: ::std::vec::Vec<u8>,
    pub version: u64,
    pub value_type: ::std::string::String,
    pub encoded: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyPair {
    fn default() -> &'a KeyPair {
        <KeyPair as ::protobuf::Message>::default_instance()
    }
}

impl KeyPair {
    pub fn new() -> KeyPair {
        ::std::default::Default::default()
    }

    // bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // uint64 version = 3;


    pub fn get_version(&self) -> u64 {
        self.version
    }
    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = v;
    }

    // string value_type = 4;


    pub fn get_value_type(&self) -> &str {
        &self.value_type
    }
    pub fn clear_value_type(&mut self) {
        self.value_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_value_type(&mut self, v: ::std::string::String) {
        self.value_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value_type(&mut self) -> &mut ::std::string::String {
        &mut self.value_type
    }

    // Take field
    pub fn take_value_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value_type, ::std::string::String::new())
    }

    // bool encoded = 6;


    pub fn get_encoded(&self) -> bool {
        self.encoded
    }
    pub fn clear_encoded(&mut self) {
        self.encoded = false;
    }

    // Param is passed by value, moved
    pub fn set_encoded(&mut self, v: bool) {
        self.encoded = v;
    }
}

impl ::protobuf::Message for KeyPair {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.version = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value_type)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.encoded = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(3, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.value_type.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.value_type);
        }
        if self.encoded != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        if self.version != 0 {
            os.write_uint64(3, self.version)?;
        }
        if !self.value_type.is_empty() {
            os.write_string(4, &self.value_type)?;
        }
        if self.encoded != false {
            os.write_bool(6, self.encoded)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyPair {
        KeyPair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "key",
                |m: &KeyPair| { &m.key },
                |m: &mut KeyPair| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value",
                |m: &KeyPair| { &m.value },
                |m: &mut KeyPair| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "version",
                |m: &KeyPair| { &m.version },
                |m: &mut KeyPair| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value_type",
                |m: &KeyPair| { &m.value_type },
                |m: &mut KeyPair| { &mut m.value_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "encoded",
                |m: &KeyPair| { &m.encoded },
                |m: &mut KeyPair| { &mut m.encoded },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyPair>(
                "KeyPair",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeyPair {
        static instance: ::protobuf::rt::LazyV2<KeyPair> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeyPair::new)
    }
}

impl ::protobuf::Clear for KeyPair {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.version = 0;
        self.value_type.clear();
        self.encoded = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyPair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyPair {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyValuePair {
    // message fields
    pub key: ::std::string::String,
    pub value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyValuePair {
    fn default() -> &'a KeyValuePair {
        <KeyValuePair as ::protobuf::Message>::default_instance()
    }
}

impl KeyValuePair {
    pub fn new() -> KeyValuePair {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for KeyValuePair {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyValuePair {
        KeyValuePair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &KeyValuePair| { &m.key },
                |m: &mut KeyValuePair| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value",
                |m: &KeyValuePair| { &m.value },
                |m: &mut KeyValuePair| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyValuePair>(
                "KeyValuePair",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeyValuePair {
        static instance: ::protobuf::rt::LazyV2<KeyValuePair> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeyValuePair::new)
    }
}

impl ::protobuf::Clear for KeyValuePair {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyValuePair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyValuePair {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Signature {
    // message fields
    pub public_key: ::std::vec::Vec<u8>,
    pub sign_data: ::std::vec::Vec<u8>,
    pub encryption_type: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Signature {
    fn default() -> &'a Signature {
        <Signature as ::protobuf::Message>::default_instance()
    }
}

impl Signature {
    pub fn new() -> Signature {
        ::std::default::Default::default()
    }

    // bytes public_key = 1;


    pub fn get_public_key(&self) -> &[u8] {
        &self.public_key
    }
    pub fn clear_public_key(&mut self) {
        self.public_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.public_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.public_key
    }

    // Take field
    pub fn take_public_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.public_key, ::std::vec::Vec::new())
    }

    // bytes sign_data = 2;


    pub fn get_sign_data(&self) -> &[u8] {
        &self.sign_data
    }
    pub fn clear_sign_data(&mut self) {
        self.sign_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_sign_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.sign_data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sign_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.sign_data
    }

    // Take field
    pub fn take_sign_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.sign_data, ::std::vec::Vec::new())
    }

    // string encryption_type = 3;


    pub fn get_encryption_type(&self) -> &str {
        &self.encryption_type
    }
    pub fn clear_encryption_type(&mut self) {
        self.encryption_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_encryption_type(&mut self, v: ::std::string::String) {
        self.encryption_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption_type(&mut self) -> &mut ::std::string::String {
        &mut self.encryption_type
    }

    // Take field
    pub fn take_encryption_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.encryption_type, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Signature {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.public_key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.sign_data)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.encryption_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.public_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.public_key);
        }
        if !self.sign_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.sign_data);
        }
        if !self.encryption_type.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.encryption_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.public_key.is_empty() {
            os.write_bytes(1, &self.public_key)?;
        }
        if !self.sign_data.is_empty() {
            os.write_bytes(2, &self.sign_data)?;
        }
        if !self.encryption_type.is_empty() {
            os.write_string(3, &self.encryption_type)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Signature {
        Signature::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "public_key",
                |m: &Signature| { &m.public_key },
                |m: &mut Signature| { &mut m.public_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sign_data",
                |m: &Signature| { &m.sign_data },
                |m: &mut Signature| { &mut m.sign_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "encryption_type",
                |m: &Signature| { &m.encryption_type },
                |m: &mut Signature| { &mut m.encryption_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Signature>(
                "Signature",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Signature {
        static instance: ::protobuf::rt::LazyV2<Signature> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Signature::new)
    }
}

impl ::protobuf::Clear for Signature {
    fn clear(&mut self) {
        self.public_key.clear();
        self.sign_data.clear();
        self.encryption_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Signature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Signature {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Validator {
    // message fields
    pub address: ::std::string::String,
    pub pledge_amount: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Validator {
    fn default() -> &'a Validator {
        <Validator as ::protobuf::Message>::default_instance()
    }
}

impl Validator {
    pub fn new() -> Validator {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // int64 pledge_amount = 2;


    pub fn get_pledge_amount(&self) -> i64 {
        self.pledge_amount
    }
    pub fn clear_pledge_amount(&mut self) {
        self.pledge_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_pledge_amount(&mut self, v: i64) {
        self.pledge_amount = v;
    }
}

impl ::protobuf::Message for Validator {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.pledge_amount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.pledge_amount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.pledge_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.pledge_amount != 0 {
            os.write_int64(2, self.pledge_amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Validator {
        Validator::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &Validator| { &m.address },
                |m: &mut Validator| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "pledge_amount",
                |m: &Validator| { &m.pledge_amount },
                |m: &mut Validator| { &mut m.pledge_amount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Validator>(
                "Validator",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Validator {
        static instance: ::protobuf::rt::LazyV2<Validator> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Validator::new)
    }
}

impl ::protobuf::Clear for Validator {
    fn clear(&mut self) {
        self.address.clear();
        self.pledge_amount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Validator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Validator {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ValidatorSet {
    // message fields
    pub epoch: u64,
    pub validators: ::protobuf::RepeatedField<Validator>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ValidatorSet {
    fn default() -> &'a ValidatorSet {
        <ValidatorSet as ::protobuf::Message>::default_instance()
    }
}

impl ValidatorSet {
    pub fn new() -> ValidatorSet {
        ::std::default::Default::default()
    }

    // uint64 epoch = 1;


    pub fn get_epoch(&self) -> u64 {
        self.epoch
    }
    pub fn clear_epoch(&mut self) {
        self.epoch = 0;
    }

    // Param is passed by value, moved
    pub fn set_epoch(&mut self, v: u64) {
        self.epoch = v;
    }

    // repeated .Validator validators = 2;


    pub fn get_validators(&self) -> &[Validator] {
        &self.validators
    }
    pub fn clear_validators(&mut self) {
        self.validators.clear();
    }

    // Param is passed by value, moved
    pub fn set_validators(&mut self, v: ::protobuf::RepeatedField<Validator>) {
        self.validators = v;
    }

    // Mutable pointer to the field.
    pub fn mut_validators(&mut self) -> &mut ::protobuf::RepeatedField<Validator> {
        &mut self.validators
    }

    // Take field
    pub fn take_validators(&mut self) -> ::protobuf::RepeatedField<Validator> {
        ::std::mem::replace(&mut self.validators, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ValidatorSet {
    fn is_initialized(&self) -> bool {
        for v in &self.validators {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.epoch = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.validators)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.epoch != 0 {
            my_size += ::protobuf::rt::value_size(1, self.epoch, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.validators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.epoch != 0 {
            os.write_uint64(1, self.epoch)?;
        }
        for v in &self.validators {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ValidatorSet {
        ValidatorSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "epoch",
                |m: &ValidatorSet| { &m.epoch },
                |m: &mut ValidatorSet| { &mut m.epoch },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Validator>>(
                "validators",
                |m: &ValidatorSet| { &m.validators },
                |m: &mut ValidatorSet| { &mut m.validators },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ValidatorSet>(
                "ValidatorSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ValidatorSet {
        static instance: ::protobuf::rt::LazyV2<ValidatorSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ValidatorSet::new)
    }
}

impl ::protobuf::Clear for ValidatorSet {
    fn clear(&mut self) {
        self.epoch = 0;
        self.validators.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ValidatorSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatorSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EntryList {
    // message fields
    pub entry: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EntryList {
    fn default() -> &'a EntryList {
        <EntryList as ::protobuf::Message>::default_instance()
    }
}

impl EntryList {
    pub fn new() -> EntryList {
        ::std::default::Default::default()
    }

    // repeated bytes entry = 1;


    pub fn get_entry(&self) -> &[::std::vec::Vec<u8>] {
        &self.entry
    }
    pub fn clear_entry(&mut self) {
        self.entry.clear();
    }

    // Param is passed by value, moved
    pub fn set_entry(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.entry = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entry(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.entry
    }

    // Take field
    pub fn take_entry(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.entry, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for EntryList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.entry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entry {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entry {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EntryList {
        EntryList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "entry",
                |m: &EntryList| { &m.entry },
                |m: &mut EntryList| { &mut m.entry },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EntryList>(
                "EntryList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EntryList {
        static instance: ::protobuf::rt::LazyV2<EntryList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EntryList::new)
    }
}

impl ::protobuf::Clear for EntryList {
    fn clear(&mut self) {
        self.entry.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EntryList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EntryList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HelloMessage {
    // message fields
    pub network_id: u64,
    pub ledger_version: u64,
    pub network_version: u64,
    pub chain_version: ::std::string::String,
    pub listening_port: i64,
    pub node_address: ::std::string::String,
    pub node_rand: ::std::string::String,
    pub chain_id: ::std::string::String,
    pub chain_hub: ::std::string::String,
    pub license: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HelloMessage {
    fn default() -> &'a HelloMessage {
        <HelloMessage as ::protobuf::Message>::default_instance()
    }
}

impl HelloMessage {
    pub fn new() -> HelloMessage {
        ::std::default::Default::default()
    }

    // uint64 network_id = 1;


    pub fn get_network_id(&self) -> u64 {
        self.network_id
    }
    pub fn clear_network_id(&mut self) {
        self.network_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_network_id(&mut self, v: u64) {
        self.network_id = v;
    }

    // uint64 ledger_version = 2;


    pub fn get_ledger_version(&self) -> u64 {
        self.ledger_version
    }
    pub fn clear_ledger_version(&mut self) {
        self.ledger_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_ledger_version(&mut self, v: u64) {
        self.ledger_version = v;
    }

    // uint64 network_version = 3;


    pub fn get_network_version(&self) -> u64 {
        self.network_version
    }
    pub fn clear_network_version(&mut self) {
        self.network_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_network_version(&mut self, v: u64) {
        self.network_version = v;
    }

    // string chain_version = 4;


    pub fn get_chain_version(&self) -> &str {
        &self.chain_version
    }
    pub fn clear_chain_version(&mut self) {
        self.chain_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_chain_version(&mut self, v: ::std::string::String) {
        self.chain_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chain_version(&mut self) -> &mut ::std::string::String {
        &mut self.chain_version
    }

    // Take field
    pub fn take_chain_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.chain_version, ::std::string::String::new())
    }

    // int64 listening_port = 5;


    pub fn get_listening_port(&self) -> i64 {
        self.listening_port
    }
    pub fn clear_listening_port(&mut self) {
        self.listening_port = 0;
    }

    // Param is passed by value, moved
    pub fn set_listening_port(&mut self, v: i64) {
        self.listening_port = v;
    }

    // string node_address = 6;


    pub fn get_node_address(&self) -> &str {
        &self.node_address
    }
    pub fn clear_node_address(&mut self) {
        self.node_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_address(&mut self, v: ::std::string::String) {
        self.node_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_address(&mut self) -> &mut ::std::string::String {
        &mut self.node_address
    }

    // Take field
    pub fn take_node_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_address, ::std::string::String::new())
    }

    // string node_rand = 7;


    pub fn get_node_rand(&self) -> &str {
        &self.node_rand
    }
    pub fn clear_node_rand(&mut self) {
        self.node_rand.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_rand(&mut self, v: ::std::string::String) {
        self.node_rand = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_rand(&mut self) -> &mut ::std::string::String {
        &mut self.node_rand
    }

    // Take field
    pub fn take_node_rand(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_rand, ::std::string::String::new())
    }

    // string chain_id = 8;


    pub fn get_chain_id(&self) -> &str {
        &self.chain_id
    }
    pub fn clear_chain_id(&mut self) {
        self.chain_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_chain_id(&mut self, v: ::std::string::String) {
        self.chain_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chain_id(&mut self) -> &mut ::std::string::String {
        &mut self.chain_id
    }

    // Take field
    pub fn take_chain_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.chain_id, ::std::string::String::new())
    }

    // string chain_hub = 9;


    pub fn get_chain_hub(&self) -> &str {
        &self.chain_hub
    }
    pub fn clear_chain_hub(&mut self) {
        self.chain_hub.clear();
    }

    // Param is passed by value, moved
    pub fn set_chain_hub(&mut self, v: ::std::string::String) {
        self.chain_hub = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chain_hub(&mut self) -> &mut ::std::string::String {
        &mut self.chain_hub
    }

    // Take field
    pub fn take_chain_hub(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.chain_hub, ::std::string::String::new())
    }

    // string license = 10;


    pub fn get_license(&self) -> &str {
        &self.license
    }
    pub fn clear_license(&mut self) {
        self.license.clear();
    }

    // Param is passed by value, moved
    pub fn set_license(&mut self, v: ::std::string::String) {
        self.license = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_license(&mut self) -> &mut ::std::string::String {
        &mut self.license
    }

    // Take field
    pub fn take_license(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.license, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HelloMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.network_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ledger_version = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.network_version = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.chain_version)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.listening_port = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_address)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_rand)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.chain_id)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.chain_hub)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.license)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.network_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.network_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ledger_version != 0 {
            my_size += ::protobuf::rt::value_size(2, self.ledger_version, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.network_version != 0 {
            my_size += ::protobuf::rt::value_size(3, self.network_version, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.chain_version.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.chain_version);
        }
        if self.listening_port != 0 {
            my_size += ::protobuf::rt::value_size(5, self.listening_port, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.node_address.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.node_address);
        }
        if !self.node_rand.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.node_rand);
        }
        if !self.chain_id.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.chain_id);
        }
        if !self.chain_hub.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.chain_hub);
        }
        if !self.license.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.license);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.network_id != 0 {
            os.write_uint64(1, self.network_id)?;
        }
        if self.ledger_version != 0 {
            os.write_uint64(2, self.ledger_version)?;
        }
        if self.network_version != 0 {
            os.write_uint64(3, self.network_version)?;
        }
        if !self.chain_version.is_empty() {
            os.write_string(4, &self.chain_version)?;
        }
        if self.listening_port != 0 {
            os.write_int64(5, self.listening_port)?;
        }
        if !self.node_address.is_empty() {
            os.write_string(6, &self.node_address)?;
        }
        if !self.node_rand.is_empty() {
            os.write_string(7, &self.node_rand)?;
        }
        if !self.chain_id.is_empty() {
            os.write_string(8, &self.chain_id)?;
        }
        if !self.chain_hub.is_empty() {
            os.write_string(9, &self.chain_hub)?;
        }
        if !self.license.is_empty() {
            os.write_string(10, &self.license)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HelloMessage {
        HelloMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "network_id",
                |m: &HelloMessage| { &m.network_id },
                |m: &mut HelloMessage| { &mut m.network_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "ledger_version",
                |m: &HelloMessage| { &m.ledger_version },
                |m: &mut HelloMessage| { &mut m.ledger_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "network_version",
                |m: &HelloMessage| { &m.network_version },
                |m: &mut HelloMessage| { &mut m.network_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "chain_version",
                |m: &HelloMessage| { &m.chain_version },
                |m: &mut HelloMessage| { &mut m.chain_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "listening_port",
                |m: &HelloMessage| { &m.listening_port },
                |m: &mut HelloMessage| { &mut m.listening_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_address",
                |m: &HelloMessage| { &m.node_address },
                |m: &mut HelloMessage| { &mut m.node_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_rand",
                |m: &HelloMessage| { &m.node_rand },
                |m: &mut HelloMessage| { &mut m.node_rand },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "chain_id",
                |m: &HelloMessage| { &m.chain_id },
                |m: &mut HelloMessage| { &mut m.chain_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "chain_hub",
                |m: &HelloMessage| { &m.chain_hub },
                |m: &mut HelloMessage| { &mut m.chain_hub },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "license",
                |m: &HelloMessage| { &m.license },
                |m: &mut HelloMessage| { &mut m.license },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HelloMessage>(
                "HelloMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HelloMessage {
        static instance: ::protobuf::rt::LazyV2<HelloMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HelloMessage::new)
    }
}

impl ::protobuf::Clear for HelloMessage {
    fn clear(&mut self) {
        self.network_id = 0;
        self.ledger_version = 0;
        self.network_version = 0;
        self.chain_version.clear();
        self.listening_port = 0;
        self.node_address.clear();
        self.node_rand.clear();
        self.chain_id.clear();
        self.chain_hub.clear();
        self.license.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HelloMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HelloMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HelloResponseMessage {
    // message fields
    pub err_code: i32,
    pub err_desc: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HelloResponseMessage {
    fn default() -> &'a HelloResponseMessage {
        <HelloResponseMessage as ::protobuf::Message>::default_instance()
    }
}

impl HelloResponseMessage {
    pub fn new() -> HelloResponseMessage {
        ::std::default::Default::default()
    }

    // int32 err_code = 1;


    pub fn get_err_code(&self) -> i32 {
        self.err_code
    }
    pub fn clear_err_code(&mut self) {
        self.err_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_err_code(&mut self, v: i32) {
        self.err_code = v;
    }

    // string err_desc = 2;


    pub fn get_err_desc(&self) -> &str {
        &self.err_desc
    }
    pub fn clear_err_desc(&mut self) {
        self.err_desc.clear();
    }

    // Param is passed by value, moved
    pub fn set_err_desc(&mut self, v: ::std::string::String) {
        self.err_desc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_err_desc(&mut self) -> &mut ::std::string::String {
        &mut self.err_desc
    }

    // Take field
    pub fn take_err_desc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.err_desc, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HelloResponseMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.err_code = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.err_desc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.err_code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.err_code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.err_desc.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.err_desc);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.err_code != 0 {
            os.write_int32(1, self.err_code)?;
        }
        if !self.err_desc.is_empty() {
            os.write_string(2, &self.err_desc)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HelloResponseMessage {
        HelloResponseMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "err_code",
                |m: &HelloResponseMessage| { &m.err_code },
                |m: &mut HelloResponseMessage| { &mut m.err_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "err_desc",
                |m: &HelloResponseMessage| { &m.err_desc },
                |m: &mut HelloResponseMessage| { &mut m.err_desc },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HelloResponseMessage>(
                "HelloResponseMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HelloResponseMessage {
        static instance: ::protobuf::rt::LazyV2<HelloResponseMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HelloResponseMessage::new)
    }
}

impl ::protobuf::Clear for HelloResponseMessage {
    fn clear(&mut self) {
        self.err_code = 0;
        self.err_desc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HelloResponseMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HelloResponseMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionResult {
    // message fields
    pub err_code: i32,
    pub message: ::std::string::String,
    pub contract_result: ::protobuf::SingularPtrField<ContractResult>,
    pub gas_used: u64,
    pub block_height: u64,
    pub block_hash: ::std::vec::Vec<u8>,
    pub index: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionResult {
    fn default() -> &'a TransactionResult {
        <TransactionResult as ::protobuf::Message>::default_instance()
    }
}

impl TransactionResult {
    pub fn new() -> TransactionResult {
        ::std::default::Default::default()
    }

    // int32 err_code = 1;


    pub fn get_err_code(&self) -> i32 {
        self.err_code
    }
    pub fn clear_err_code(&mut self) {
        self.err_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_err_code(&mut self, v: i32) {
        self.err_code = v;
    }

    // string message = 2;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    // .ContractResult contract_result = 3;


    pub fn get_contract_result(&self) -> &ContractResult {
        self.contract_result.as_ref().unwrap_or_else(|| <ContractResult as ::protobuf::Message>::default_instance())
    }
    pub fn clear_contract_result(&mut self) {
        self.contract_result.clear();
    }

    pub fn has_contract_result(&self) -> bool {
        self.contract_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contract_result(&mut self, v: ContractResult) {
        self.contract_result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_result(&mut self) -> &mut ContractResult {
        if self.contract_result.is_none() {
            self.contract_result.set_default();
        }
        self.contract_result.as_mut().unwrap()
    }

    // Take field
    pub fn take_contract_result(&mut self) -> ContractResult {
        self.contract_result.take().unwrap_or_else(|| ContractResult::new())
    }

    // uint64 gas_used = 4;


    pub fn get_gas_used(&self) -> u64 {
        self.gas_used
    }
    pub fn clear_gas_used(&mut self) {
        self.gas_used = 0;
    }

    // Param is passed by value, moved
    pub fn set_gas_used(&mut self, v: u64) {
        self.gas_used = v;
    }

    // uint64 block_height = 5;


    pub fn get_block_height(&self) -> u64 {
        self.block_height
    }
    pub fn clear_block_height(&mut self) {
        self.block_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_height(&mut self, v: u64) {
        self.block_height = v;
    }

    // bytes block_hash = 6;


    pub fn get_block_hash(&self) -> &[u8] {
        &self.block_hash
    }
    pub fn clear_block_hash(&mut self) {
        self.block_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.block_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.block_hash
    }

    // Take field
    pub fn take_block_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.block_hash, ::std::vec::Vec::new())
    }

    // uint32 index = 7;


    pub fn get_index(&self) -> u32 {
        self.index
    }
    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = v;
    }
}

impl ::protobuf::Message for TransactionResult {
    fn is_initialized(&self) -> bool {
        for v in &self.contract_result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.err_code = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.contract_result)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gas_used = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.block_height = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.block_hash)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.err_code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.err_code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        if let Some(ref v) = self.contract_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.gas_used != 0 {
            my_size += ::protobuf::rt::value_size(4, self.gas_used, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.block_height != 0 {
            my_size += ::protobuf::rt::value_size(5, self.block_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.block_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.block_hash);
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(7, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.err_code != 0 {
            os.write_int32(1, self.err_code)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        if let Some(ref v) = self.contract_result.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.gas_used != 0 {
            os.write_uint64(4, self.gas_used)?;
        }
        if self.block_height != 0 {
            os.write_uint64(5, self.block_height)?;
        }
        if !self.block_hash.is_empty() {
            os.write_bytes(6, &self.block_hash)?;
        }
        if self.index != 0 {
            os.write_uint32(7, self.index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionResult {
        TransactionResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "err_code",
                |m: &TransactionResult| { &m.err_code },
                |m: &mut TransactionResult| { &mut m.err_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &TransactionResult| { &m.message },
                |m: &mut TransactionResult| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContractResult>>(
                "contract_result",
                |m: &TransactionResult| { &m.contract_result },
                |m: &mut TransactionResult| { &mut m.contract_result },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "gas_used",
                |m: &TransactionResult| { &m.gas_used },
                |m: &mut TransactionResult| { &mut m.gas_used },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "block_height",
                |m: &TransactionResult| { &m.block_height },
                |m: &mut TransactionResult| { &mut m.block_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "block_hash",
                |m: &TransactionResult| { &m.block_hash },
                |m: &mut TransactionResult| { &mut m.block_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "index",
                |m: &TransactionResult| { &m.index },
                |m: &mut TransactionResult| { &mut m.index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransactionResult>(
                "TransactionResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransactionResult {
        static instance: ::protobuf::rt::LazyV2<TransactionResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransactionResult::new)
    }
}

impl ::protobuf::Clear for TransactionResult {
    fn clear(&mut self) {
        self.err_code = 0;
        self.message.clear();
        self.contract_result.clear();
        self.gas_used = 0;
        self.block_height = 0;
        self.block_hash.clear();
        self.index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContractResult {
    // message fields
    pub err_code: i32,
    pub result: ::std::vec::Vec<u8>,
    pub message: ::std::string::String,
    pub contract_event: ::protobuf::RepeatedField<ContractEvent>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContractResult {
    fn default() -> &'a ContractResult {
        <ContractResult as ::protobuf::Message>::default_instance()
    }
}

impl ContractResult {
    pub fn new() -> ContractResult {
        ::std::default::Default::default()
    }

    // int32 err_code = 1;


    pub fn get_err_code(&self) -> i32 {
        self.err_code
    }
    pub fn clear_err_code(&mut self) {
        self.err_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_err_code(&mut self, v: i32) {
        self.err_code = v;
    }

    // bytes result = 2;


    pub fn get_result(&self) -> &[u8] {
        &self.result
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ::std::vec::Vec<u8>) {
        self.result = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.result
    }

    // Take field
    pub fn take_result(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.result, ::std::vec::Vec::new())
    }

    // string message = 3;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    // repeated .ContractEvent contract_event = 4;


    pub fn get_contract_event(&self) -> &[ContractEvent] {
        &self.contract_event
    }
    pub fn clear_contract_event(&mut self) {
        self.contract_event.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_event(&mut self, v: ::protobuf::RepeatedField<ContractEvent>) {
        self.contract_event = v;
    }

    // Mutable pointer to the field.
    pub fn mut_contract_event(&mut self) -> &mut ::protobuf::RepeatedField<ContractEvent> {
        &mut self.contract_event
    }

    // Take field
    pub fn take_contract_event(&mut self) -> ::protobuf::RepeatedField<ContractEvent> {
        ::std::mem::replace(&mut self.contract_event, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ContractResult {
    fn is_initialized(&self) -> bool {
        for v in &self.contract_event {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.err_code = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.result)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.contract_event)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.err_code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.err_code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.result.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.result);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        for value in &self.contract_event {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.err_code != 0 {
            os.write_int32(1, self.err_code)?;
        }
        if !self.result.is_empty() {
            os.write_bytes(2, &self.result)?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        for v in &self.contract_event {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContractResult {
        ContractResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "err_code",
                |m: &ContractResult| { &m.err_code },
                |m: &mut ContractResult| { &mut m.err_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "result",
                |m: &ContractResult| { &m.result },
                |m: &mut ContractResult| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &ContractResult| { &m.message },
                |m: &mut ContractResult| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContractEvent>>(
                "contract_event",
                |m: &ContractResult| { &m.contract_event },
                |m: &mut ContractResult| { &mut m.contract_event },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContractResult>(
                "ContractResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContractResult {
        static instance: ::protobuf::rt::LazyV2<ContractResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContractResult::new)
    }
}

impl ::protobuf::Clear for ContractResult {
    fn clear(&mut self) {
        self.err_code = 0;
        self.result.clear();
        self.message.clear();
        self.contract_event.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContractResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContractResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContractEvent {
    // message fields
    pub address: ::std::string::String,
    pub topic: ::protobuf::RepeatedField<::std::string::String>,
    pub data: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContractEvent {
    fn default() -> &'a ContractEvent {
        <ContractEvent as ::protobuf::Message>::default_instance()
    }
}

impl ContractEvent {
    pub fn new() -> ContractEvent {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // repeated string topic = 2;


    pub fn get_topic(&self) -> &[::std::string::String] {
        &self.topic
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.topic = v;
    }

    // Mutable pointer to the field.
    pub fn mut_topic(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.topic
    }

    // Take field
    pub fn take_topic(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.topic, ::protobuf::RepeatedField::new())
    }

    // repeated string data = 3;


    pub fn get_data(&self) -> &[::std::string::String] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ContractEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.topic)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        for value in &self.topic {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.data {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        for v in &self.topic {
            os.write_string(2, &v)?;
        };
        for v in &self.data {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContractEvent {
        ContractEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &ContractEvent| { &m.address },
                |m: &mut ContractEvent| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "topic",
                |m: &ContractEvent| { &m.topic },
                |m: &mut ContractEvent| { &mut m.topic },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "data",
                |m: &ContractEvent| { &m.data },
                |m: &mut ContractEvent| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContractEvent>(
                "ContractEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContractEvent {
        static instance: ::protobuf::rt::LazyV2<ContractEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContractEvent::new)
    }
}

impl ::protobuf::Clear for ContractEvent {
    fn clear(&mut self) {
        self.address.clear();
        self.topic.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContractEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContractEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ProtocolsActionMessageType {
    BROADCAST = 0,
    REQUEST = 1,
    RESPONSE = 2,
}

impl ::protobuf::ProtobufEnum for ProtocolsActionMessageType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtocolsActionMessageType> {
        match value {
            0 => ::std::option::Option::Some(ProtocolsActionMessageType::BROADCAST),
            1 => ::std::option::Option::Some(ProtocolsActionMessageType::REQUEST),
            2 => ::std::option::Option::Some(ProtocolsActionMessageType::RESPONSE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ProtocolsActionMessageType] = &[
            ProtocolsActionMessageType::BROADCAST,
            ProtocolsActionMessageType::REQUEST,
            ProtocolsActionMessageType::RESPONSE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ProtocolsActionMessageType>("ProtocolsActionMessageType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ProtocolsActionMessageType {
}

impl ::std::default::Default for ProtocolsActionMessageType {
    fn default() -> Self {
        ProtocolsActionMessageType::BROADCAST
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtocolsActionMessageType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ProtocolsMessageType {
    NONE = 0,
    HELLO = 1,
    PING = 2,
    PEERS = 3,
    TRANSACTION = 4,
    SYNCCHAIN = 5,
    CONSENSUS = 6,
    LEDGER_UPGRADE_NOTIFY = 7,
    LIGHT = 8,
    TRANSACTION_SYNC = 9,
    SYNCBLOCK = 10,
}

impl ::protobuf::ProtobufEnum for ProtocolsMessageType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtocolsMessageType> {
        match value {
            0 => ::std::option::Option::Some(ProtocolsMessageType::NONE),
            1 => ::std::option::Option::Some(ProtocolsMessageType::HELLO),
            2 => ::std::option::Option::Some(ProtocolsMessageType::PING),
            3 => ::std::option::Option::Some(ProtocolsMessageType::PEERS),
            4 => ::std::option::Option::Some(ProtocolsMessageType::TRANSACTION),
            5 => ::std::option::Option::Some(ProtocolsMessageType::SYNCCHAIN),
            6 => ::std::option::Option::Some(ProtocolsMessageType::CONSENSUS),
            7 => ::std::option::Option::Some(ProtocolsMessageType::LEDGER_UPGRADE_NOTIFY),
            8 => ::std::option::Option::Some(ProtocolsMessageType::LIGHT),
            9 => ::std::option::Option::Some(ProtocolsMessageType::TRANSACTION_SYNC),
            10 => ::std::option::Option::Some(ProtocolsMessageType::SYNCBLOCK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ProtocolsMessageType] = &[
            ProtocolsMessageType::NONE,
            ProtocolsMessageType::HELLO,
            ProtocolsMessageType::PING,
            ProtocolsMessageType::PEERS,
            ProtocolsMessageType::TRANSACTION,
            ProtocolsMessageType::SYNCCHAIN,
            ProtocolsMessageType::CONSENSUS,
            ProtocolsMessageType::LEDGER_UPGRADE_NOTIFY,
            ProtocolsMessageType::LIGHT,
            ProtocolsMessageType::TRANSACTION_SYNC,
            ProtocolsMessageType::SYNCBLOCK,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ProtocolsMessageType>("ProtocolsMessageType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ProtocolsMessageType {
}

impl ::std::default::Default for ProtocolsMessageType {
    fn default() -> Self {
        ProtocolsMessageType::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtocolsMessageType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0ccommon.proto\"\x81\x02\n\x10ProtocolsMessage\x122\n\x08msg_type\
    \x18\x01\x20\x01(\x0e2\x15.ProtocolsMessageTypeR\x07msgTypeB\0\x125\n\
    \x06action\x18\x02\x20\x01(\x0e2\x1b.ProtocolsActionMessageTypeR\x06acti\
    onB\0\x12\x1c\n\x08sequence\x18\x03\x20\x01(\x04R\x08sequenceB\0\x12\x14\
    \n\x04data\x18\x04\x20\x01(\x0cR\x04dataB\0\x12\x1e\n\ttimestamp\x18\x05\
    \x20\x01(\x03R\ttimestampB\0\x12\x16\n\x05route\x18\x06\x20\x03(\tR\x05r\
    outeB\0\x12\x14\n\x04hash\x18\x07\x20\x01(\tR\x04hashB\0:\0\"\x20\n\x04P\
    ing\x12\x16\n\x05nonce\x18\x01\x20\x01(\x03R\x05nonceB\0:\0\"\x20\n\x04P\
    ong\x12\x16\n\x05nonce\x18\x01\x20\x01(\x03R\x05nonceB\0:\0\"\xc1\x01\n\
    \x04Peer\x12\x1a\n\x07address\x18\x01\x20\x01(\tR\x07addressB\0\x12#\n\
    \x0cnum_failures\x18\x02\x20\x01(\x03R\x0bnumFailuresB\0\x12,\n\x11next_\
    attempt_time\x18\x03\x20\x01(\x03R\x0fnextAttemptTimeB\0\x12!\n\x0bactiv\
    e_time\x18\x04\x20\x01(\x03R\nactiveTimeB\0\x12%\n\rconnection_id\x18\
    \x05\x20\x01(\x03R\x0cconnectionIdB\0:\0\"(\n\x05Peers\x12\x1d\n\x05peer\
    s\x18\x01\x20\x03(\x0b2\x05.PeerR\x05peersB\0:\0\"\x90\x01\n\x07KeyPair\
    \x12\x12\n\x03key\x18\x01\x20\x01(\x0cR\x03keyB\0\x12\x16\n\x05value\x18\
    \x02\x20\x01(\x0cR\x05valueB\0\x12\x1a\n\x07version\x18\x03\x20\x01(\x04\
    R\x07versionB\0\x12\x1f\n\nvalue_type\x18\x04\x20\x01(\tR\tvalueTypeB\0\
    \x12\x1a\n\x07encoded\x18\x06\x20\x01(\x08R\x07encodedB\0:\0\"<\n\x0cKey\
    ValuePair\x12\x12\n\x03key\x18\x01\x20\x01(\tR\x03keyB\0\x12\x16\n\x05va\
    lue\x18\x02\x20\x01(\x0cR\x05valueB\0:\0\"x\n\tSignature\x12\x1f\n\npubl\
    ic_key\x18\x01\x20\x01(\x0cR\tpublicKeyB\0\x12\x1d\n\tsign_data\x18\x02\
    \x20\x01(\x0cR\x08signDataB\0\x12)\n\x0fencryption_type\x18\x03\x20\x01(\
    \tR\x0eencryptionTypeB\0:\0\"P\n\tValidator\x12\x1a\n\x07address\x18\x01\
    \x20\x01(\tR\x07addressB\0\x12%\n\rpledge_amount\x18\x02\x20\x01(\x03R\
    \x0cpledgeAmountB\0:\0\"V\n\x0cValidatorSet\x12\x16\n\x05epoch\x18\x01\
    \x20\x01(\x04R\x05epochB\0\x12,\n\nvalidators\x18\x02\x20\x03(\x0b2\n.Va\
    lidatorR\nvalidatorsB\0:\0\"%\n\tEntryList\x12\x16\n\x05entry\x18\x01\
    \x20\x03(\x0cR\x05entryB\0:\0\"\xf1\x02\n\x0cHelloMessage\x12\x1f\n\nnet\
    work_id\x18\x01\x20\x01(\x04R\tnetworkIdB\0\x12'\n\x0eledger_version\x18\
    \x02\x20\x01(\x04R\rledgerVersionB\0\x12)\n\x0fnetwork_version\x18\x03\
    \x20\x01(\x04R\x0enetworkVersionB\0\x12%\n\rchain_version\x18\x04\x20\
    \x01(\tR\x0cchainVersionB\0\x12'\n\x0elistening_port\x18\x05\x20\x01(\
    \x03R\rlisteningPortB\0\x12#\n\x0cnode_address\x18\x06\x20\x01(\tR\x0bno\
    deAddressB\0\x12\x1d\n\tnode_rand\x18\x07\x20\x01(\tR\x08nodeRandB\0\x12\
    \x1b\n\x08chain_id\x18\x08\x20\x01(\tR\x07chainIdB\0\x12\x1d\n\tchain_hu\
    b\x18\t\x20\x01(\tR\x08chainHubB\0\x12\x1a\n\x07license\x18\n\x20\x01(\t\
    R\x07licenseB\0:\0\"R\n\x14HelloResponseMessage\x12\x1b\n\x08err_code\
    \x18\x01\x20\x01(\x05R\x07errCodeB\0\x12\x1b\n\x08err_desc\x18\x02\x20\
    \x01(\tR\x07errDescB\0:\0\"\x85\x02\n\x11TransactionResult\x12\x1b\n\x08\
    err_code\x18\x01\x20\x01(\x05R\x07errCodeB\0\x12\x1a\n\x07message\x18\
    \x02\x20\x01(\tR\x07messageB\0\x12:\n\x0fcontract_result\x18\x03\x20\x01\
    (\x0b2\x0f.ContractResultR\x0econtractResultB\0\x12\x1b\n\x08gas_used\
    \x18\x04\x20\x01(\x04R\x07gasUsedB\0\x12#\n\x0cblock_height\x18\x05\x20\
    \x01(\x04R\x0bblockHeightB\0\x12\x1f\n\nblock_hash\x18\x06\x20\x01(\x0cR\
    \tblockHashB\0\x12\x16\n\x05index\x18\x07\x20\x01(\rR\x05indexB\0:\0\"\
    \x9e\x01\n\x0eContractResult\x12\x1b\n\x08err_code\x18\x01\x20\x01(\x05R\
    \x07errCodeB\0\x12\x18\n\x06result\x18\x02\x20\x01(\x0cR\x06resultB\0\
    \x12\x1a\n\x07message\x18\x03\x20\x01(\tR\x07messageB\0\x127\n\x0econtra\
    ct_event\x18\x04\x20\x03(\x0b2\x0e.ContractEventR\rcontractEventB\0:\0\"\
    [\n\rContractEvent\x12\x1a\n\x07address\x18\x01\x20\x01(\tR\x07addressB\
    \0\x12\x16\n\x05topic\x18\x02\x20\x03(\tR\x05topicB\0\x12\x14\n\x04data\
    \x18\x03\x20\x03(\tR\x04dataB\0:\0*H\n\x1aProtocolsActionMessageType\x12\
    \r\n\tBROADCAST\x10\0\x12\x0b\n\x07REQUEST\x10\x01\x12\x0c\n\x08RESPONSE\
    \x10\x02\x1a\0*\xbc\x01\n\x14ProtocolsMessageType\x12\x08\n\x04NONE\x10\
    \0\x12\t\n\x05HELLO\x10\x01\x12\x08\n\x04PING\x10\x02\x12\t\n\x05PEERS\
    \x10\x03\x12\x0f\n\x0bTRANSACTION\x10\x04\x12\r\n\tSYNCCHAIN\x10\x05\x12\
    \r\n\tCONSENSUS\x10\x06\x12\x19\n\x15LEDGER_UPGRADE_NOTIFY\x10\x07\x12\t\
    \n\x05LIGHT\x10\x08\x12\x14\n\x10TRANSACTION_SYNC\x10\t\x12\r\n\tSYNCBLO\
    CK\x10\n\x1a\0B\0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
