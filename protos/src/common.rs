// This file is generated by rust-protobuf 2.25.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `common.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_0;

#[derive(PartialEq,Clone,Default)]
pub struct ProtocolsMessage {
    // message fields
    pub msg_type: ProtocolsMessageType,
    pub action: ProtocolsActionMessageType,
    pub sequence: u64,
    pub data: ::std::vec::Vec<u8>,
    pub timestamp: i64,
    pub route: ::protobuf::RepeatedField<::std::string::String>,
    pub hash: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProtocolsMessage {
    fn default() -> &'a ProtocolsMessage {
        <ProtocolsMessage as ::protobuf::Message>::default_instance()
    }
}

impl ProtocolsMessage {
    pub fn new() -> ProtocolsMessage {
        ::std::default::Default::default()
    }

    // .ProtocolsMessageType msg_type = 1;


    pub fn get_msg_type(&self) -> ProtocolsMessageType {
        self.msg_type
    }
    pub fn clear_msg_type(&mut self) {
        self.msg_type = ProtocolsMessageType::NONE;
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: ProtocolsMessageType) {
        self.msg_type = v;
    }

    // .ProtocolsActionMessageType action = 2;


    pub fn get_action(&self) -> ProtocolsActionMessageType {
        self.action
    }
    pub fn clear_action(&mut self) {
        self.action = ProtocolsActionMessageType::BROADCAST;
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ProtocolsActionMessageType) {
        self.action = v;
    }

    // uint64 sequence = 3;


    pub fn get_sequence(&self) -> u64 {
        self.sequence
    }
    pub fn clear_sequence(&mut self) {
        self.sequence = 0;
    }

    // Param is passed by value, moved
    pub fn set_sequence(&mut self, v: u64) {
        self.sequence = v;
    }

    // bytes data = 4;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // int64 timestamp = 5;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // repeated string route = 6;


    pub fn get_route(&self) -> &[::std::string::String] {
        &self.route
    }
    pub fn clear_route(&mut self) {
        self.route.clear();
    }

    // Param is passed by value, moved
    pub fn set_route(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.route = v;
    }

    // Mutable pointer to the field.
    pub fn mut_route(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.route
    }

    // Take field
    pub fn take_route(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.route, ::protobuf::RepeatedField::new())
    }

    // string hash = 7;


    pub fn get_hash(&self) -> &str {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::string::String) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::string::String {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hash, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ProtocolsMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.msg_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sequence = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.route)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.msg_type != ProtocolsMessageType::NONE {
            my_size += ::protobuf::rt::enum_size(1, self.msg_type);
        }
        if self.action != ProtocolsActionMessageType::BROADCAST {
            my_size += ::protobuf::rt::enum_size(2, self.action);
        }
        if self.sequence != 0 {
            my_size += ::protobuf::rt::value_size(3, self.sequence, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.data);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(5, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.route {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.msg_type != ProtocolsMessageType::NONE {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.msg_type))?;
        }
        if self.action != ProtocolsActionMessageType::BROADCAST {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.action))?;
        }
        if self.sequence != 0 {
            os.write_uint64(3, self.sequence)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(4, &self.data)?;
        }
        if self.timestamp != 0 {
            os.write_int64(5, self.timestamp)?;
        }
        for v in &self.route {
            os.write_string(6, &v)?;
        };
        if !self.hash.is_empty() {
            os.write_string(7, &self.hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProtocolsMessage {
        ProtocolsMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ProtocolsMessageType>>(
                "msg_type",
                |m: &ProtocolsMessage| { &m.msg_type },
                |m: &mut ProtocolsMessage| { &mut m.msg_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ProtocolsActionMessageType>>(
                "action",
                |m: &ProtocolsMessage| { &m.action },
                |m: &mut ProtocolsMessage| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "sequence",
                |m: &ProtocolsMessage| { &m.sequence },
                |m: &mut ProtocolsMessage| { &mut m.sequence },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &ProtocolsMessage| { &m.data },
                |m: &mut ProtocolsMessage| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp",
                |m: &ProtocolsMessage| { &m.timestamp },
                |m: &mut ProtocolsMessage| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "route",
                |m: &ProtocolsMessage| { &m.route },
                |m: &mut ProtocolsMessage| { &mut m.route },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hash",
                |m: &ProtocolsMessage| { &m.hash },
                |m: &mut ProtocolsMessage| { &mut m.hash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProtocolsMessage>(
                "ProtocolsMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProtocolsMessage {
        static instance: ::protobuf::rt::LazyV2<ProtocolsMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProtocolsMessage::new)
    }
}

impl ::protobuf::Clear for ProtocolsMessage {
    fn clear(&mut self) {
        self.msg_type = ProtocolsMessageType::NONE;
        self.action = ProtocolsActionMessageType::BROADCAST;
        self.sequence = 0;
        self.data.clear();
        self.timestamp = 0;
        self.route.clear();
        self.hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProtocolsMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtocolsMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Ping {
    // message fields
    pub nonce: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Ping {
    fn default() -> &'a Ping {
        <Ping as ::protobuf::Message>::default_instance()
    }
}

impl Ping {
    pub fn new() -> Ping {
        ::std::default::Default::default()
    }

    // int64 nonce = 1;


    pub fn get_nonce(&self) -> i64 {
        self.nonce
    }
    pub fn clear_nonce(&mut self) {
        self.nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: i64) {
        self.nonce = v;
    }
}

impl ::protobuf::Message for Ping {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.nonce = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.nonce != 0 {
            my_size += ::protobuf::rt::value_size(1, self.nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.nonce != 0 {
            os.write_int64(1, self.nonce)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Ping {
        Ping::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "nonce",
                |m: &Ping| { &m.nonce },
                |m: &mut Ping| { &mut m.nonce },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Ping>(
                "Ping",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Ping {
        static instance: ::protobuf::rt::LazyV2<Ping> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Ping::new)
    }
}

impl ::protobuf::Clear for Ping {
    fn clear(&mut self) {
        self.nonce = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Ping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ping {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Pong {
    // message fields
    pub nonce: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Pong {
    fn default() -> &'a Pong {
        <Pong as ::protobuf::Message>::default_instance()
    }
}

impl Pong {
    pub fn new() -> Pong {
        ::std::default::Default::default()
    }

    // int64 nonce = 1;


    pub fn get_nonce(&self) -> i64 {
        self.nonce
    }
    pub fn clear_nonce(&mut self) {
        self.nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: i64) {
        self.nonce = v;
    }
}

impl ::protobuf::Message for Pong {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.nonce = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.nonce != 0 {
            my_size += ::protobuf::rt::value_size(1, self.nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.nonce != 0 {
            os.write_int64(1, self.nonce)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pong {
        Pong::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "nonce",
                |m: &Pong| { &m.nonce },
                |m: &mut Pong| { &mut m.nonce },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Pong>(
                "Pong",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Pong {
        static instance: ::protobuf::rt::LazyV2<Pong> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Pong::new)
    }
}

impl ::protobuf::Clear for Pong {
    fn clear(&mut self) {
        self.nonce = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Pong {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pong {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Peer {
    // message fields
    pub address: ::std::string::String,
    pub num_failures: i64,
    pub next_attempt_time: i64,
    pub active_time: i64,
    pub connection_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Peer {
    fn default() -> &'a Peer {
        <Peer as ::protobuf::Message>::default_instance()
    }
}

impl Peer {
    pub fn new() -> Peer {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // int64 num_failures = 2;


    pub fn get_num_failures(&self) -> i64 {
        self.num_failures
    }
    pub fn clear_num_failures(&mut self) {
        self.num_failures = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_failures(&mut self, v: i64) {
        self.num_failures = v;
    }

    // int64 next_attempt_time = 3;


    pub fn get_next_attempt_time(&self) -> i64 {
        self.next_attempt_time
    }
    pub fn clear_next_attempt_time(&mut self) {
        self.next_attempt_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_next_attempt_time(&mut self, v: i64) {
        self.next_attempt_time = v;
    }

    // int64 active_time = 4;


    pub fn get_active_time(&self) -> i64 {
        self.active_time
    }
    pub fn clear_active_time(&mut self) {
        self.active_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_active_time(&mut self, v: i64) {
        self.active_time = v;
    }

    // int64 connection_id = 5;


    pub fn get_connection_id(&self) -> i64 {
        self.connection_id
    }
    pub fn clear_connection_id(&mut self) {
        self.connection_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: i64) {
        self.connection_id = v;
    }
}

impl ::protobuf::Message for Peer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.num_failures = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.next_attempt_time = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.active_time = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.connection_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.num_failures != 0 {
            my_size += ::protobuf::rt::value_size(2, self.num_failures, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.next_attempt_time != 0 {
            my_size += ::protobuf::rt::value_size(3, self.next_attempt_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.active_time != 0 {
            my_size += ::protobuf::rt::value_size(4, self.active_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.connection_id != 0 {
            my_size += ::protobuf::rt::value_size(5, self.connection_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.num_failures != 0 {
            os.write_int64(2, self.num_failures)?;
        }
        if self.next_attempt_time != 0 {
            os.write_int64(3, self.next_attempt_time)?;
        }
        if self.active_time != 0 {
            os.write_int64(4, self.active_time)?;
        }
        if self.connection_id != 0 {
            os.write_int64(5, self.connection_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Peer {
        Peer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &Peer| { &m.address },
                |m: &mut Peer| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "num_failures",
                |m: &Peer| { &m.num_failures },
                |m: &mut Peer| { &mut m.num_failures },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "next_attempt_time",
                |m: &Peer| { &m.next_attempt_time },
                |m: &mut Peer| { &mut m.next_attempt_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "active_time",
                |m: &Peer| { &m.active_time },
                |m: &mut Peer| { &mut m.active_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "connection_id",
                |m: &Peer| { &m.connection_id },
                |m: &mut Peer| { &mut m.connection_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Peer>(
                "Peer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Peer {
        static instance: ::protobuf::rt::LazyV2<Peer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Peer::new)
    }
}

impl ::protobuf::Clear for Peer {
    fn clear(&mut self) {
        self.address.clear();
        self.num_failures = 0;
        self.next_attempt_time = 0;
        self.active_time = 0;
        self.connection_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Peer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Peer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Peers {
    // message fields
    pub peers: ::protobuf::RepeatedField<Peer>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Peers {
    fn default() -> &'a Peers {
        <Peers as ::protobuf::Message>::default_instance()
    }
}

impl Peers {
    pub fn new() -> Peers {
        ::std::default::Default::default()
    }

    // repeated .Peer peers = 1;


    pub fn get_peers(&self) -> &[Peer] {
        &self.peers
    }
    pub fn clear_peers(&mut self) {
        self.peers.clear();
    }

    // Param is passed by value, moved
    pub fn set_peers(&mut self, v: ::protobuf::RepeatedField<Peer>) {
        self.peers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peers(&mut self) -> &mut ::protobuf::RepeatedField<Peer> {
        &mut self.peers
    }

    // Take field
    pub fn take_peers(&mut self) -> ::protobuf::RepeatedField<Peer> {
        ::std::mem::replace(&mut self.peers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Peers {
    fn is_initialized(&self) -> bool {
        for v in &self.peers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.peers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.peers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.peers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Peers {
        Peers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Peer>>(
                "peers",
                |m: &Peers| { &m.peers },
                |m: &mut Peers| { &mut m.peers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Peers>(
                "Peers",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Peers {
        static instance: ::protobuf::rt::LazyV2<Peers> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Peers::new)
    }
}

impl ::protobuf::Clear for Peers {
    fn clear(&mut self) {
        self.peers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Peers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Peers {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyPair {
    // message fields
    pub key: ::std::vec::Vec<u8>,
    pub value: ::std::vec::Vec<u8>,
    pub version: u64,
    pub value_type: ::std::string::String,
    pub encoded: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyPair {
    fn default() -> &'a KeyPair {
        <KeyPair as ::protobuf::Message>::default_instance()
    }
}

impl KeyPair {
    pub fn new() -> KeyPair {
        ::std::default::Default::default()
    }

    // bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // uint64 version = 3;


    pub fn get_version(&self) -> u64 {
        self.version
    }
    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = v;
    }

    // string value_type = 4;


    pub fn get_value_type(&self) -> &str {
        &self.value_type
    }
    pub fn clear_value_type(&mut self) {
        self.value_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_value_type(&mut self, v: ::std::string::String) {
        self.value_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value_type(&mut self) -> &mut ::std::string::String {
        &mut self.value_type
    }

    // Take field
    pub fn take_value_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value_type, ::std::string::String::new())
    }

    // bool encoded = 6;


    pub fn get_encoded(&self) -> bool {
        self.encoded
    }
    pub fn clear_encoded(&mut self) {
        self.encoded = false;
    }

    // Param is passed by value, moved
    pub fn set_encoded(&mut self, v: bool) {
        self.encoded = v;
    }
}

impl ::protobuf::Message for KeyPair {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.version = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value_type)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.encoded = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(3, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.value_type.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.value_type);
        }
        if self.encoded != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        if self.version != 0 {
            os.write_uint64(3, self.version)?;
        }
        if !self.value_type.is_empty() {
            os.write_string(4, &self.value_type)?;
        }
        if self.encoded != false {
            os.write_bool(6, self.encoded)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyPair {
        KeyPair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "key",
                |m: &KeyPair| { &m.key },
                |m: &mut KeyPair| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value",
                |m: &KeyPair| { &m.value },
                |m: &mut KeyPair| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "version",
                |m: &KeyPair| { &m.version },
                |m: &mut KeyPair| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value_type",
                |m: &KeyPair| { &m.value_type },
                |m: &mut KeyPair| { &mut m.value_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "encoded",
                |m: &KeyPair| { &m.encoded },
                |m: &mut KeyPair| { &mut m.encoded },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyPair>(
                "KeyPair",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeyPair {
        static instance: ::protobuf::rt::LazyV2<KeyPair> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeyPair::new)
    }
}

impl ::protobuf::Clear for KeyPair {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.version = 0;
        self.value_type.clear();
        self.encoded = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyPair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyPair {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyValuePair {
    // message fields
    pub key: ::std::string::String,
    pub value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyValuePair {
    fn default() -> &'a KeyValuePair {
        <KeyValuePair as ::protobuf::Message>::default_instance()
    }
}

impl KeyValuePair {
    pub fn new() -> KeyValuePair {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for KeyValuePair {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyValuePair {
        KeyValuePair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &KeyValuePair| { &m.key },
                |m: &mut KeyValuePair| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value",
                |m: &KeyValuePair| { &m.value },
                |m: &mut KeyValuePair| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyValuePair>(
                "KeyValuePair",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeyValuePair {
        static instance: ::protobuf::rt::LazyV2<KeyValuePair> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeyValuePair::new)
    }
}

impl ::protobuf::Clear for KeyValuePair {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyValuePair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyValuePair {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Signature {
    // message fields
    pub public_key: ::std::vec::Vec<u8>,
    pub sign_data: ::std::vec::Vec<u8>,
    pub encryption_type: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Signature {
    fn default() -> &'a Signature {
        <Signature as ::protobuf::Message>::default_instance()
    }
}

impl Signature {
    pub fn new() -> Signature {
        ::std::default::Default::default()
    }

    // bytes public_key = 1;


    pub fn get_public_key(&self) -> &[u8] {
        &self.public_key
    }
    pub fn clear_public_key(&mut self) {
        self.public_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.public_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.public_key
    }

    // Take field
    pub fn take_public_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.public_key, ::std::vec::Vec::new())
    }

    // bytes sign_data = 2;


    pub fn get_sign_data(&self) -> &[u8] {
        &self.sign_data
    }
    pub fn clear_sign_data(&mut self) {
        self.sign_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_sign_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.sign_data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sign_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.sign_data
    }

    // Take field
    pub fn take_sign_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.sign_data, ::std::vec::Vec::new())
    }

    // string encryption_type = 3;


    pub fn get_encryption_type(&self) -> &str {
        &self.encryption_type
    }
    pub fn clear_encryption_type(&mut self) {
        self.encryption_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_encryption_type(&mut self, v: ::std::string::String) {
        self.encryption_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption_type(&mut self) -> &mut ::std::string::String {
        &mut self.encryption_type
    }

    // Take field
    pub fn take_encryption_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.encryption_type, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Signature {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.public_key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.sign_data)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.encryption_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.public_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.public_key);
        }
        if !self.sign_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.sign_data);
        }
        if !self.encryption_type.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.encryption_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.public_key.is_empty() {
            os.write_bytes(1, &self.public_key)?;
        }
        if !self.sign_data.is_empty() {
            os.write_bytes(2, &self.sign_data)?;
        }
        if !self.encryption_type.is_empty() {
            os.write_string(3, &self.encryption_type)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Signature {
        Signature::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "public_key",
                |m: &Signature| { &m.public_key },
                |m: &mut Signature| { &mut m.public_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sign_data",
                |m: &Signature| { &m.sign_data },
                |m: &mut Signature| { &mut m.sign_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "encryption_type",
                |m: &Signature| { &m.encryption_type },
                |m: &mut Signature| { &mut m.encryption_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Signature>(
                "Signature",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Signature {
        static instance: ::protobuf::rt::LazyV2<Signature> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Signature::new)
    }
}

impl ::protobuf::Clear for Signature {
    fn clear(&mut self) {
        self.public_key.clear();
        self.sign_data.clear();
        self.encryption_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Signature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Signature {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Validator {
    // message fields
    pub address: ::std::string::String,
    pub pledge_amount: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Validator {
    fn default() -> &'a Validator {
        <Validator as ::protobuf::Message>::default_instance()
    }
}

impl Validator {
    pub fn new() -> Validator {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // int64 pledge_amount = 2;


    pub fn get_pledge_amount(&self) -> i64 {
        self.pledge_amount
    }
    pub fn clear_pledge_amount(&mut self) {
        self.pledge_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_pledge_amount(&mut self, v: i64) {
        self.pledge_amount = v;
    }
}

impl ::protobuf::Message for Validator {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.pledge_amount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.pledge_amount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.pledge_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.pledge_amount != 0 {
            os.write_int64(2, self.pledge_amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Validator {
        Validator::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &Validator| { &m.address },
                |m: &mut Validator| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "pledge_amount",
                |m: &Validator| { &m.pledge_amount },
                |m: &mut Validator| { &mut m.pledge_amount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Validator>(
                "Validator",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Validator {
        static instance: ::protobuf::rt::LazyV2<Validator> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Validator::new)
    }
}

impl ::protobuf::Clear for Validator {
    fn clear(&mut self) {
        self.address.clear();
        self.pledge_amount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Validator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Validator {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ValidatorSet {
    // message fields
    pub validators: ::protobuf::RepeatedField<Validator>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ValidatorSet {
    fn default() -> &'a ValidatorSet {
        <ValidatorSet as ::protobuf::Message>::default_instance()
    }
}

impl ValidatorSet {
    pub fn new() -> ValidatorSet {
        ::std::default::Default::default()
    }

    // repeated .Validator validators = 1;


    pub fn get_validators(&self) -> &[Validator] {
        &self.validators
    }
    pub fn clear_validators(&mut self) {
        self.validators.clear();
    }

    // Param is passed by value, moved
    pub fn set_validators(&mut self, v: ::protobuf::RepeatedField<Validator>) {
        self.validators = v;
    }

    // Mutable pointer to the field.
    pub fn mut_validators(&mut self) -> &mut ::protobuf::RepeatedField<Validator> {
        &mut self.validators
    }

    // Take field
    pub fn take_validators(&mut self) -> ::protobuf::RepeatedField<Validator> {
        ::std::mem::replace(&mut self.validators, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ValidatorSet {
    fn is_initialized(&self) -> bool {
        for v in &self.validators {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.validators)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.validators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.validators {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ValidatorSet {
        ValidatorSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Validator>>(
                "validators",
                |m: &ValidatorSet| { &m.validators },
                |m: &mut ValidatorSet| { &mut m.validators },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ValidatorSet>(
                "ValidatorSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ValidatorSet {
        static instance: ::protobuf::rt::LazyV2<ValidatorSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ValidatorSet::new)
    }
}

impl ::protobuf::Clear for ValidatorSet {
    fn clear(&mut self) {
        self.validators.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ValidatorSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatorSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EntryList {
    // message fields
    pub entry: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EntryList {
    fn default() -> &'a EntryList {
        <EntryList as ::protobuf::Message>::default_instance()
    }
}

impl EntryList {
    pub fn new() -> EntryList {
        ::std::default::Default::default()
    }

    // repeated bytes entry = 1;


    pub fn get_entry(&self) -> &[::std::vec::Vec<u8>] {
        &self.entry
    }
    pub fn clear_entry(&mut self) {
        self.entry.clear();
    }

    // Param is passed by value, moved
    pub fn set_entry(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.entry = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entry(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.entry
    }

    // Take field
    pub fn take_entry(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.entry, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for EntryList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.entry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entry {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entry {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EntryList {
        EntryList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "entry",
                |m: &EntryList| { &m.entry },
                |m: &mut EntryList| { &mut m.entry },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EntryList>(
                "EntryList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EntryList {
        static instance: ::protobuf::rt::LazyV2<EntryList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EntryList::new)
    }
}

impl ::protobuf::Clear for EntryList {
    fn clear(&mut self) {
        self.entry.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EntryList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EntryList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HelloMessage {
    // message fields
    pub network_id: u64,
    pub ledger_version: u64,
    pub network_version: u64,
    pub chain_version: ::std::string::String,
    pub listening_port: i64,
    pub node_address: ::std::string::String,
    pub node_rand: ::std::string::String,
    pub chain_id: ::std::string::String,
    pub chain_hub: ::std::string::String,
    pub license: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HelloMessage {
    fn default() -> &'a HelloMessage {
        <HelloMessage as ::protobuf::Message>::default_instance()
    }
}

impl HelloMessage {
    pub fn new() -> HelloMessage {
        ::std::default::Default::default()
    }

    // uint64 network_id = 1;


    pub fn get_network_id(&self) -> u64 {
        self.network_id
    }
    pub fn clear_network_id(&mut self) {
        self.network_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_network_id(&mut self, v: u64) {
        self.network_id = v;
    }

    // uint64 ledger_version = 2;


    pub fn get_ledger_version(&self) -> u64 {
        self.ledger_version
    }
    pub fn clear_ledger_version(&mut self) {
        self.ledger_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_ledger_version(&mut self, v: u64) {
        self.ledger_version = v;
    }

    // uint64 network_version = 3;


    pub fn get_network_version(&self) -> u64 {
        self.network_version
    }
    pub fn clear_network_version(&mut self) {
        self.network_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_network_version(&mut self, v: u64) {
        self.network_version = v;
    }

    // string chain_version = 4;


    pub fn get_chain_version(&self) -> &str {
        &self.chain_version
    }
    pub fn clear_chain_version(&mut self) {
        self.chain_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_chain_version(&mut self, v: ::std::string::String) {
        self.chain_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chain_version(&mut self) -> &mut ::std::string::String {
        &mut self.chain_version
    }

    // Take field
    pub fn take_chain_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.chain_version, ::std::string::String::new())
    }

    // int64 listening_port = 5;


    pub fn get_listening_port(&self) -> i64 {
        self.listening_port
    }
    pub fn clear_listening_port(&mut self) {
        self.listening_port = 0;
    }

    // Param is passed by value, moved
    pub fn set_listening_port(&mut self, v: i64) {
        self.listening_port = v;
    }

    // string node_address = 6;


    pub fn get_node_address(&self) -> &str {
        &self.node_address
    }
    pub fn clear_node_address(&mut self) {
        self.node_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_address(&mut self, v: ::std::string::String) {
        self.node_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_address(&mut self) -> &mut ::std::string::String {
        &mut self.node_address
    }

    // Take field
    pub fn take_node_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_address, ::std::string::String::new())
    }

    // string node_rand = 7;


    pub fn get_node_rand(&self) -> &str {
        &self.node_rand
    }
    pub fn clear_node_rand(&mut self) {
        self.node_rand.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_rand(&mut self, v: ::std::string::String) {
        self.node_rand = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_rand(&mut self) -> &mut ::std::string::String {
        &mut self.node_rand
    }

    // Take field
    pub fn take_node_rand(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_rand, ::std::string::String::new())
    }

    // string chain_id = 8;


    pub fn get_chain_id(&self) -> &str {
        &self.chain_id
    }
    pub fn clear_chain_id(&mut self) {
        self.chain_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_chain_id(&mut self, v: ::std::string::String) {
        self.chain_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chain_id(&mut self) -> &mut ::std::string::String {
        &mut self.chain_id
    }

    // Take field
    pub fn take_chain_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.chain_id, ::std::string::String::new())
    }

    // string chain_hub = 9;


    pub fn get_chain_hub(&self) -> &str {
        &self.chain_hub
    }
    pub fn clear_chain_hub(&mut self) {
        self.chain_hub.clear();
    }

    // Param is passed by value, moved
    pub fn set_chain_hub(&mut self, v: ::std::string::String) {
        self.chain_hub = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chain_hub(&mut self) -> &mut ::std::string::String {
        &mut self.chain_hub
    }

    // Take field
    pub fn take_chain_hub(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.chain_hub, ::std::string::String::new())
    }

    // string license = 10;


    pub fn get_license(&self) -> &str {
        &self.license
    }
    pub fn clear_license(&mut self) {
        self.license.clear();
    }

    // Param is passed by value, moved
    pub fn set_license(&mut self, v: ::std::string::String) {
        self.license = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_license(&mut self) -> &mut ::std::string::String {
        &mut self.license
    }

    // Take field
    pub fn take_license(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.license, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HelloMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.network_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ledger_version = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.network_version = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.chain_version)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.listening_port = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_address)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_rand)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.chain_id)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.chain_hub)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.license)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.network_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.network_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ledger_version != 0 {
            my_size += ::protobuf::rt::value_size(2, self.ledger_version, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.network_version != 0 {
            my_size += ::protobuf::rt::value_size(3, self.network_version, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.chain_version.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.chain_version);
        }
        if self.listening_port != 0 {
            my_size += ::protobuf::rt::value_size(5, self.listening_port, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.node_address.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.node_address);
        }
        if !self.node_rand.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.node_rand);
        }
        if !self.chain_id.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.chain_id);
        }
        if !self.chain_hub.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.chain_hub);
        }
        if !self.license.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.license);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.network_id != 0 {
            os.write_uint64(1, self.network_id)?;
        }
        if self.ledger_version != 0 {
            os.write_uint64(2, self.ledger_version)?;
        }
        if self.network_version != 0 {
            os.write_uint64(3, self.network_version)?;
        }
        if !self.chain_version.is_empty() {
            os.write_string(4, &self.chain_version)?;
        }
        if self.listening_port != 0 {
            os.write_int64(5, self.listening_port)?;
        }
        if !self.node_address.is_empty() {
            os.write_string(6, &self.node_address)?;
        }
        if !self.node_rand.is_empty() {
            os.write_string(7, &self.node_rand)?;
        }
        if !self.chain_id.is_empty() {
            os.write_string(8, &self.chain_id)?;
        }
        if !self.chain_hub.is_empty() {
            os.write_string(9, &self.chain_hub)?;
        }
        if !self.license.is_empty() {
            os.write_string(10, &self.license)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HelloMessage {
        HelloMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "network_id",
                |m: &HelloMessage| { &m.network_id },
                |m: &mut HelloMessage| { &mut m.network_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "ledger_version",
                |m: &HelloMessage| { &m.ledger_version },
                |m: &mut HelloMessage| { &mut m.ledger_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "network_version",
                |m: &HelloMessage| { &m.network_version },
                |m: &mut HelloMessage| { &mut m.network_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "chain_version",
                |m: &HelloMessage| { &m.chain_version },
                |m: &mut HelloMessage| { &mut m.chain_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "listening_port",
                |m: &HelloMessage| { &m.listening_port },
                |m: &mut HelloMessage| { &mut m.listening_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_address",
                |m: &HelloMessage| { &m.node_address },
                |m: &mut HelloMessage| { &mut m.node_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_rand",
                |m: &HelloMessage| { &m.node_rand },
                |m: &mut HelloMessage| { &mut m.node_rand },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "chain_id",
                |m: &HelloMessage| { &m.chain_id },
                |m: &mut HelloMessage| { &mut m.chain_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "chain_hub",
                |m: &HelloMessage| { &m.chain_hub },
                |m: &mut HelloMessage| { &mut m.chain_hub },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "license",
                |m: &HelloMessage| { &m.license },
                |m: &mut HelloMessage| { &mut m.license },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HelloMessage>(
                "HelloMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HelloMessage {
        static instance: ::protobuf::rt::LazyV2<HelloMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HelloMessage::new)
    }
}

impl ::protobuf::Clear for HelloMessage {
    fn clear(&mut self) {
        self.network_id = 0;
        self.ledger_version = 0;
        self.network_version = 0;
        self.chain_version.clear();
        self.listening_port = 0;
        self.node_address.clear();
        self.node_rand.clear();
        self.chain_id.clear();
        self.chain_hub.clear();
        self.license.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HelloMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HelloMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HelloResponseMessage {
    // message fields
    pub err_code: ErrCode,
    pub err_desc: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HelloResponseMessage {
    fn default() -> &'a HelloResponseMessage {
        <HelloResponseMessage as ::protobuf::Message>::default_instance()
    }
}

impl HelloResponseMessage {
    pub fn new() -> HelloResponseMessage {
        ::std::default::Default::default()
    }

    // .ErrCode err_code = 1;


    pub fn get_err_code(&self) -> ErrCode {
        self.err_code
    }
    pub fn clear_err_code(&mut self) {
        self.err_code = ErrCode::ERRCODE_SUCCESS;
    }

    // Param is passed by value, moved
    pub fn set_err_code(&mut self, v: ErrCode) {
        self.err_code = v;
    }

    // string err_desc = 2;


    pub fn get_err_desc(&self) -> &str {
        &self.err_desc
    }
    pub fn clear_err_desc(&mut self) {
        self.err_desc.clear();
    }

    // Param is passed by value, moved
    pub fn set_err_desc(&mut self, v: ::std::string::String) {
        self.err_desc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_err_desc(&mut self) -> &mut ::std::string::String {
        &mut self.err_desc
    }

    // Take field
    pub fn take_err_desc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.err_desc, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HelloResponseMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.err_code, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.err_desc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.err_code != ErrCode::ERRCODE_SUCCESS {
            my_size += ::protobuf::rt::enum_size(1, self.err_code);
        }
        if !self.err_desc.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.err_desc);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.err_code != ErrCode::ERRCODE_SUCCESS {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.err_code))?;
        }
        if !self.err_desc.is_empty() {
            os.write_string(2, &self.err_desc)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HelloResponseMessage {
        HelloResponseMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ErrCode>>(
                "err_code",
                |m: &HelloResponseMessage| { &m.err_code },
                |m: &mut HelloResponseMessage| { &mut m.err_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "err_desc",
                |m: &HelloResponseMessage| { &m.err_desc },
                |m: &mut HelloResponseMessage| { &mut m.err_desc },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HelloResponseMessage>(
                "HelloResponseMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HelloResponseMessage {
        static instance: ::protobuf::rt::LazyV2<HelloResponseMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HelloResponseMessage::new)
    }
}

impl ::protobuf::Clear for HelloResponseMessage {
    fn clear(&mut self) {
        self.err_code = ErrCode::ERRCODE_SUCCESS;
        self.err_desc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HelloResponseMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HelloResponseMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionResult {
    // message fields
    pub err_code: u32,
    pub message: ::std::string::String,
    pub contract_result: ::protobuf::SingularPtrField<ContractResult>,
    pub gas_used: u64,
    pub block_height: u64,
    pub block_hash: ::std::vec::Vec<u8>,
    pub index: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionResult {
    fn default() -> &'a TransactionResult {
        <TransactionResult as ::protobuf::Message>::default_instance()
    }
}

impl TransactionResult {
    pub fn new() -> TransactionResult {
        ::std::default::Default::default()
    }

    // uint32 err_code = 1;


    pub fn get_err_code(&self) -> u32 {
        self.err_code
    }
    pub fn clear_err_code(&mut self) {
        self.err_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_err_code(&mut self, v: u32) {
        self.err_code = v;
    }

    // string message = 2;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    // .ContractResult contract_result = 3;


    pub fn get_contract_result(&self) -> &ContractResult {
        self.contract_result.as_ref().unwrap_or_else(|| <ContractResult as ::protobuf::Message>::default_instance())
    }
    pub fn clear_contract_result(&mut self) {
        self.contract_result.clear();
    }

    pub fn has_contract_result(&self) -> bool {
        self.contract_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contract_result(&mut self, v: ContractResult) {
        self.contract_result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_result(&mut self) -> &mut ContractResult {
        if self.contract_result.is_none() {
            self.contract_result.set_default();
        }
        self.contract_result.as_mut().unwrap()
    }

    // Take field
    pub fn take_contract_result(&mut self) -> ContractResult {
        self.contract_result.take().unwrap_or_else(|| ContractResult::new())
    }

    // uint64 gas_used = 4;


    pub fn get_gas_used(&self) -> u64 {
        self.gas_used
    }
    pub fn clear_gas_used(&mut self) {
        self.gas_used = 0;
    }

    // Param is passed by value, moved
    pub fn set_gas_used(&mut self, v: u64) {
        self.gas_used = v;
    }

    // uint64 block_height = 5;


    pub fn get_block_height(&self) -> u64 {
        self.block_height
    }
    pub fn clear_block_height(&mut self) {
        self.block_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_height(&mut self, v: u64) {
        self.block_height = v;
    }

    // bytes block_hash = 6;


    pub fn get_block_hash(&self) -> &[u8] {
        &self.block_hash
    }
    pub fn clear_block_hash(&mut self) {
        self.block_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.block_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.block_hash
    }

    // Take field
    pub fn take_block_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.block_hash, ::std::vec::Vec::new())
    }

    // uint32 index = 7;


    pub fn get_index(&self) -> u32 {
        self.index
    }
    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = v;
    }
}

impl ::protobuf::Message for TransactionResult {
    fn is_initialized(&self) -> bool {
        for v in &self.contract_result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.err_code = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.contract_result)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gas_used = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.block_height = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.block_hash)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.err_code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.err_code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        if let Some(ref v) = self.contract_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.gas_used != 0 {
            my_size += ::protobuf::rt::value_size(4, self.gas_used, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.block_height != 0 {
            my_size += ::protobuf::rt::value_size(5, self.block_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.block_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.block_hash);
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(7, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.err_code != 0 {
            os.write_uint32(1, self.err_code)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        if let Some(ref v) = self.contract_result.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.gas_used != 0 {
            os.write_uint64(4, self.gas_used)?;
        }
        if self.block_height != 0 {
            os.write_uint64(5, self.block_height)?;
        }
        if !self.block_hash.is_empty() {
            os.write_bytes(6, &self.block_hash)?;
        }
        if self.index != 0 {
            os.write_uint32(7, self.index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionResult {
        TransactionResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "err_code",
                |m: &TransactionResult| { &m.err_code },
                |m: &mut TransactionResult| { &mut m.err_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &TransactionResult| { &m.message },
                |m: &mut TransactionResult| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContractResult>>(
                "contract_result",
                |m: &TransactionResult| { &m.contract_result },
                |m: &mut TransactionResult| { &mut m.contract_result },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "gas_used",
                |m: &TransactionResult| { &m.gas_used },
                |m: &mut TransactionResult| { &mut m.gas_used },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "block_height",
                |m: &TransactionResult| { &m.block_height },
                |m: &mut TransactionResult| { &mut m.block_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "block_hash",
                |m: &TransactionResult| { &m.block_hash },
                |m: &mut TransactionResult| { &mut m.block_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "index",
                |m: &TransactionResult| { &m.index },
                |m: &mut TransactionResult| { &mut m.index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransactionResult>(
                "TransactionResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransactionResult {
        static instance: ::protobuf::rt::LazyV2<TransactionResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransactionResult::new)
    }
}

impl ::protobuf::Clear for TransactionResult {
    fn clear(&mut self) {
        self.err_code = 0;
        self.message.clear();
        self.contract_result.clear();
        self.gas_used = 0;
        self.block_height = 0;
        self.block_hash.clear();
        self.index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContractResult {
    // message fields
    pub err_code: u32,
    pub result: ::std::vec::Vec<u8>,
    pub message: ::std::string::String,
    pub contract_event: ::protobuf::RepeatedField<ContractEvent>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContractResult {
    fn default() -> &'a ContractResult {
        <ContractResult as ::protobuf::Message>::default_instance()
    }
}

impl ContractResult {
    pub fn new() -> ContractResult {
        ::std::default::Default::default()
    }

    // uint32 err_code = 1;


    pub fn get_err_code(&self) -> u32 {
        self.err_code
    }
    pub fn clear_err_code(&mut self) {
        self.err_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_err_code(&mut self, v: u32) {
        self.err_code = v;
    }

    // bytes result = 2;


    pub fn get_result(&self) -> &[u8] {
        &self.result
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ::std::vec::Vec<u8>) {
        self.result = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.result
    }

    // Take field
    pub fn take_result(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.result, ::std::vec::Vec::new())
    }

    // string message = 3;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    // repeated .ContractEvent contract_event = 4;


    pub fn get_contract_event(&self) -> &[ContractEvent] {
        &self.contract_event
    }
    pub fn clear_contract_event(&mut self) {
        self.contract_event.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_event(&mut self, v: ::protobuf::RepeatedField<ContractEvent>) {
        self.contract_event = v;
    }

    // Mutable pointer to the field.
    pub fn mut_contract_event(&mut self) -> &mut ::protobuf::RepeatedField<ContractEvent> {
        &mut self.contract_event
    }

    // Take field
    pub fn take_contract_event(&mut self) -> ::protobuf::RepeatedField<ContractEvent> {
        ::std::mem::replace(&mut self.contract_event, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ContractResult {
    fn is_initialized(&self) -> bool {
        for v in &self.contract_event {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.err_code = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.result)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.contract_event)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.err_code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.err_code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.result.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.result);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        for value in &self.contract_event {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.err_code != 0 {
            os.write_uint32(1, self.err_code)?;
        }
        if !self.result.is_empty() {
            os.write_bytes(2, &self.result)?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        for v in &self.contract_event {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContractResult {
        ContractResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "err_code",
                |m: &ContractResult| { &m.err_code },
                |m: &mut ContractResult| { &mut m.err_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "result",
                |m: &ContractResult| { &m.result },
                |m: &mut ContractResult| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &ContractResult| { &m.message },
                |m: &mut ContractResult| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContractEvent>>(
                "contract_event",
                |m: &ContractResult| { &m.contract_event },
                |m: &mut ContractResult| { &mut m.contract_event },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContractResult>(
                "ContractResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContractResult {
        static instance: ::protobuf::rt::LazyV2<ContractResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContractResult::new)
    }
}

impl ::protobuf::Clear for ContractResult {
    fn clear(&mut self) {
        self.err_code = 0;
        self.result.clear();
        self.message.clear();
        self.contract_event.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContractResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContractResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContractEvent {
    // message fields
    pub address: ::std::string::String,
    pub topic: ::protobuf::RepeatedField<::std::string::String>,
    pub data: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContractEvent {
    fn default() -> &'a ContractEvent {
        <ContractEvent as ::protobuf::Message>::default_instance()
    }
}

impl ContractEvent {
    pub fn new() -> ContractEvent {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // repeated string topic = 2;


    pub fn get_topic(&self) -> &[::std::string::String] {
        &self.topic
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.topic = v;
    }

    // Mutable pointer to the field.
    pub fn mut_topic(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.topic
    }

    // Take field
    pub fn take_topic(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.topic, ::protobuf::RepeatedField::new())
    }

    // repeated string data = 3;


    pub fn get_data(&self) -> &[::std::string::String] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ContractEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.topic)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        for value in &self.topic {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.data {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        for v in &self.topic {
            os.write_string(2, &v)?;
        };
        for v in &self.data {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContractEvent {
        ContractEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &ContractEvent| { &m.address },
                |m: &mut ContractEvent| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "topic",
                |m: &ContractEvent| { &m.topic },
                |m: &mut ContractEvent| { &mut m.topic },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "data",
                |m: &ContractEvent| { &m.data },
                |m: &mut ContractEvent| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContractEvent>(
                "ContractEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContractEvent {
        static instance: ::protobuf::rt::LazyV2<ContractEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContractEvent::new)
    }
}

impl ::protobuf::Clear for ContractEvent {
    fn clear(&mut self) {
        self.address.clear();
        self.topic.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContractEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContractEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ProtocolsActionMessageType {
    BROADCAST = 0,
    REQUEST = 1,
    RESPONSE = 2,
}

impl ::protobuf::ProtobufEnum for ProtocolsActionMessageType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtocolsActionMessageType> {
        match value {
            0 => ::std::option::Option::Some(ProtocolsActionMessageType::BROADCAST),
            1 => ::std::option::Option::Some(ProtocolsActionMessageType::REQUEST),
            2 => ::std::option::Option::Some(ProtocolsActionMessageType::RESPONSE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ProtocolsActionMessageType] = &[
            ProtocolsActionMessageType::BROADCAST,
            ProtocolsActionMessageType::REQUEST,
            ProtocolsActionMessageType::RESPONSE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ProtocolsActionMessageType>("ProtocolsActionMessageType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ProtocolsActionMessageType {
}

impl ::std::default::Default for ProtocolsActionMessageType {
    fn default() -> Self {
        ProtocolsActionMessageType::BROADCAST
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtocolsActionMessageType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ProtocolsMessageType {
    NONE = 0,
    HELLO = 1,
    PING = 2,
    PEERS = 3,
    TRANSACTION = 4,
    LEDGERS = 5,
    CONSENSUS = 6,
    LEDGER_UPGRADE_NOTIFY = 7,
    LIGHT = 8,
    TRANSACTION_SYNC = 9,
}

impl ::protobuf::ProtobufEnum for ProtocolsMessageType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtocolsMessageType> {
        match value {
            0 => ::std::option::Option::Some(ProtocolsMessageType::NONE),
            1 => ::std::option::Option::Some(ProtocolsMessageType::HELLO),
            2 => ::std::option::Option::Some(ProtocolsMessageType::PING),
            3 => ::std::option::Option::Some(ProtocolsMessageType::PEERS),
            4 => ::std::option::Option::Some(ProtocolsMessageType::TRANSACTION),
            5 => ::std::option::Option::Some(ProtocolsMessageType::LEDGERS),
            6 => ::std::option::Option::Some(ProtocolsMessageType::CONSENSUS),
            7 => ::std::option::Option::Some(ProtocolsMessageType::LEDGER_UPGRADE_NOTIFY),
            8 => ::std::option::Option::Some(ProtocolsMessageType::LIGHT),
            9 => ::std::option::Option::Some(ProtocolsMessageType::TRANSACTION_SYNC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ProtocolsMessageType] = &[
            ProtocolsMessageType::NONE,
            ProtocolsMessageType::HELLO,
            ProtocolsMessageType::PING,
            ProtocolsMessageType::PEERS,
            ProtocolsMessageType::TRANSACTION,
            ProtocolsMessageType::LEDGERS,
            ProtocolsMessageType::CONSENSUS,
            ProtocolsMessageType::LEDGER_UPGRADE_NOTIFY,
            ProtocolsMessageType::LIGHT,
            ProtocolsMessageType::TRANSACTION_SYNC,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ProtocolsMessageType>("ProtocolsMessageType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ProtocolsMessageType {
}

impl ::std::default::Default for ProtocolsMessageType {
    fn default() -> Self {
        ProtocolsMessageType::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtocolsMessageType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ErrCode {
    ERRCODE_SUCCESS = 0,
    ERRCODE_INVALID_PARAMETER = 2,
    ERRCODE_ACCESS_DENIED = 6,
    ERRCODE_MATH_OVERFLOW = 7,
    ERRCODE_DATABASE_ERROR = 8,
    ERRCODE_TRIE_ERROR = 9,
    ERRCODE_CREATE_IDENTITY = 30,
    ERRCODE_INVALID_PUBKEY = 90,
    ERRCODE_INVALID_PRIKEY = 91,
    ERRCODE_INVALID_SIGNATURE = 93,
    ERRCODE_INVALID_ADDRESS = 94,
    ERRCODE_BAD_SEQUENCE = 99,
    ERRCODE_ACCOUNT_LOW_RESERVE = 100,
    ERRCODE_ACCOUNT_SOURCEDEST_EQUAL = 101,
    ERRCODE_ACCOUNT_DEST_EXIST = 102,
    ERRCODE_ACCOUNT_NOT_EXIST = 103,
    ERRCODE_ACCOUNT_INIT_LOW_RESERVE = 106,
    ERRCODE_FEE_NOT_ENOUGH = 111,
    ERRCODE_FEE_INVALID = 112,
    ERRCODE_OUT_OF_TXCACHE = 114,
    ERRCODE_INVALID_DATAVERSION = 144,
    ERRCODE_TX_SIZE_TOO_BIG = 146,
    ERRCODE_CONTRACT_CREATE_FAIL = 150,
    ERRCODE_CONTRACT_EXECUTE_FAIL = 151,
    ERRCODE_CONTRACT_SYNTAX_ERROR = 152,
    ERRCODE_CONTRACT_TOO_MANY_RECURSION = 153,
    ERRCODE_CONTRACT_TOO_MANY_TRANSACTIONS = 154,
    ERRCODE_CONTRACT_EXECUTE_EXPIRED = 155,
    ERRCODE_CONTRACT_NO_STATE_ERROR = 156,
    ERRCODE_CONTRACT_NO_SCHEMA_ERROR = 157,
    ERRCODE_CONTRACT_PARAMETER_ERROR = 158,
    ERRCODE_CONTRACT_NO_FUNCTION_ERROR = 159,
    ERRCODE_TX_INSERT_QUEUE_FAIL = 160,
    ERRCODE_VALIDATOE_PROPOSAL_ERROR = 161,
    ERRCODE_VALIDATOE_VOTE_ERROR = 162,
    ERRCODE_CONTRACT_UPDATE_ERROR = 163,
}

impl ::protobuf::ProtobufEnum for ErrCode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ErrCode> {
        match value {
            0 => ::std::option::Option::Some(ErrCode::ERRCODE_SUCCESS),
            2 => ::std::option::Option::Some(ErrCode::ERRCODE_INVALID_PARAMETER),
            6 => ::std::option::Option::Some(ErrCode::ERRCODE_ACCESS_DENIED),
            7 => ::std::option::Option::Some(ErrCode::ERRCODE_MATH_OVERFLOW),
            8 => ::std::option::Option::Some(ErrCode::ERRCODE_DATABASE_ERROR),
            9 => ::std::option::Option::Some(ErrCode::ERRCODE_TRIE_ERROR),
            30 => ::std::option::Option::Some(ErrCode::ERRCODE_CREATE_IDENTITY),
            90 => ::std::option::Option::Some(ErrCode::ERRCODE_INVALID_PUBKEY),
            91 => ::std::option::Option::Some(ErrCode::ERRCODE_INVALID_PRIKEY),
            93 => ::std::option::Option::Some(ErrCode::ERRCODE_INVALID_SIGNATURE),
            94 => ::std::option::Option::Some(ErrCode::ERRCODE_INVALID_ADDRESS),
            99 => ::std::option::Option::Some(ErrCode::ERRCODE_BAD_SEQUENCE),
            100 => ::std::option::Option::Some(ErrCode::ERRCODE_ACCOUNT_LOW_RESERVE),
            101 => ::std::option::Option::Some(ErrCode::ERRCODE_ACCOUNT_SOURCEDEST_EQUAL),
            102 => ::std::option::Option::Some(ErrCode::ERRCODE_ACCOUNT_DEST_EXIST),
            103 => ::std::option::Option::Some(ErrCode::ERRCODE_ACCOUNT_NOT_EXIST),
            106 => ::std::option::Option::Some(ErrCode::ERRCODE_ACCOUNT_INIT_LOW_RESERVE),
            111 => ::std::option::Option::Some(ErrCode::ERRCODE_FEE_NOT_ENOUGH),
            112 => ::std::option::Option::Some(ErrCode::ERRCODE_FEE_INVALID),
            114 => ::std::option::Option::Some(ErrCode::ERRCODE_OUT_OF_TXCACHE),
            144 => ::std::option::Option::Some(ErrCode::ERRCODE_INVALID_DATAVERSION),
            146 => ::std::option::Option::Some(ErrCode::ERRCODE_TX_SIZE_TOO_BIG),
            150 => ::std::option::Option::Some(ErrCode::ERRCODE_CONTRACT_CREATE_FAIL),
            151 => ::std::option::Option::Some(ErrCode::ERRCODE_CONTRACT_EXECUTE_FAIL),
            152 => ::std::option::Option::Some(ErrCode::ERRCODE_CONTRACT_SYNTAX_ERROR),
            153 => ::std::option::Option::Some(ErrCode::ERRCODE_CONTRACT_TOO_MANY_RECURSION),
            154 => ::std::option::Option::Some(ErrCode::ERRCODE_CONTRACT_TOO_MANY_TRANSACTIONS),
            155 => ::std::option::Option::Some(ErrCode::ERRCODE_CONTRACT_EXECUTE_EXPIRED),
            156 => ::std::option::Option::Some(ErrCode::ERRCODE_CONTRACT_NO_STATE_ERROR),
            157 => ::std::option::Option::Some(ErrCode::ERRCODE_CONTRACT_NO_SCHEMA_ERROR),
            158 => ::std::option::Option::Some(ErrCode::ERRCODE_CONTRACT_PARAMETER_ERROR),
            159 => ::std::option::Option::Some(ErrCode::ERRCODE_CONTRACT_NO_FUNCTION_ERROR),
            160 => ::std::option::Option::Some(ErrCode::ERRCODE_TX_INSERT_QUEUE_FAIL),
            161 => ::std::option::Option::Some(ErrCode::ERRCODE_VALIDATOE_PROPOSAL_ERROR),
            162 => ::std::option::Option::Some(ErrCode::ERRCODE_VALIDATOE_VOTE_ERROR),
            163 => ::std::option::Option::Some(ErrCode::ERRCODE_CONTRACT_UPDATE_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ErrCode] = &[
            ErrCode::ERRCODE_SUCCESS,
            ErrCode::ERRCODE_INVALID_PARAMETER,
            ErrCode::ERRCODE_ACCESS_DENIED,
            ErrCode::ERRCODE_MATH_OVERFLOW,
            ErrCode::ERRCODE_DATABASE_ERROR,
            ErrCode::ERRCODE_TRIE_ERROR,
            ErrCode::ERRCODE_CREATE_IDENTITY,
            ErrCode::ERRCODE_INVALID_PUBKEY,
            ErrCode::ERRCODE_INVALID_PRIKEY,
            ErrCode::ERRCODE_INVALID_SIGNATURE,
            ErrCode::ERRCODE_INVALID_ADDRESS,
            ErrCode::ERRCODE_BAD_SEQUENCE,
            ErrCode::ERRCODE_ACCOUNT_LOW_RESERVE,
            ErrCode::ERRCODE_ACCOUNT_SOURCEDEST_EQUAL,
            ErrCode::ERRCODE_ACCOUNT_DEST_EXIST,
            ErrCode::ERRCODE_ACCOUNT_NOT_EXIST,
            ErrCode::ERRCODE_ACCOUNT_INIT_LOW_RESERVE,
            ErrCode::ERRCODE_FEE_NOT_ENOUGH,
            ErrCode::ERRCODE_FEE_INVALID,
            ErrCode::ERRCODE_OUT_OF_TXCACHE,
            ErrCode::ERRCODE_INVALID_DATAVERSION,
            ErrCode::ERRCODE_TX_SIZE_TOO_BIG,
            ErrCode::ERRCODE_CONTRACT_CREATE_FAIL,
            ErrCode::ERRCODE_CONTRACT_EXECUTE_FAIL,
            ErrCode::ERRCODE_CONTRACT_SYNTAX_ERROR,
            ErrCode::ERRCODE_CONTRACT_TOO_MANY_RECURSION,
            ErrCode::ERRCODE_CONTRACT_TOO_MANY_TRANSACTIONS,
            ErrCode::ERRCODE_CONTRACT_EXECUTE_EXPIRED,
            ErrCode::ERRCODE_CONTRACT_NO_STATE_ERROR,
            ErrCode::ERRCODE_CONTRACT_NO_SCHEMA_ERROR,
            ErrCode::ERRCODE_CONTRACT_PARAMETER_ERROR,
            ErrCode::ERRCODE_CONTRACT_NO_FUNCTION_ERROR,
            ErrCode::ERRCODE_TX_INSERT_QUEUE_FAIL,
            ErrCode::ERRCODE_VALIDATOE_PROPOSAL_ERROR,
            ErrCode::ERRCODE_VALIDATOE_VOTE_ERROR,
            ErrCode::ERRCODE_CONTRACT_UPDATE_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ErrCode>("ErrCode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ErrCode {
}

impl ::std::default::Default for ErrCode {
    fn default() -> Self {
        ErrCode::ERRCODE_SUCCESS
    }
}

impl ::protobuf::reflect::ProtobufValue for ErrCode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0ccommon.proto\"\xf1\x01\n\x10ProtocolsMessage\x120\n\x08msg_type\
    \x18\x01\x20\x01(\x0e2\x15.ProtocolsMessageTypeR\x07msgType\x123\n\x06ac\
    tion\x18\x02\x20\x01(\x0e2\x1b.ProtocolsActionMessageTypeR\x06action\x12\
    \x1a\n\x08sequence\x18\x03\x20\x01(\x04R\x08sequence\x12\x12\n\x04data\
    \x18\x04\x20\x01(\x0cR\x04data\x12\x1c\n\ttimestamp\x18\x05\x20\x01(\x03\
    R\ttimestamp\x12\x14\n\x05route\x18\x06\x20\x03(\tR\x05route\x12\x12\n\
    \x04hash\x18\x07\x20\x01(\tR\x04hash\"\x1c\n\x04Ping\x12\x14\n\x05nonce\
    \x18\x01\x20\x01(\x03R\x05nonce\"\x1c\n\x04Pong\x12\x14\n\x05nonce\x18\
    \x01\x20\x01(\x03R\x05nonce\"\xb5\x01\n\x04Peer\x12\x18\n\x07address\x18\
    \x01\x20\x01(\tR\x07address\x12!\n\x0cnum_failures\x18\x02\x20\x01(\x03R\
    \x0bnumFailures\x12*\n\x11next_attempt_time\x18\x03\x20\x01(\x03R\x0fnex\
    tAttemptTime\x12\x1f\n\x0bactive_time\x18\x04\x20\x01(\x03R\nactiveTime\
    \x12#\n\rconnection_id\x18\x05\x20\x01(\x03R\x0cconnectionId\"$\n\x05Pee\
    rs\x12\x1b\n\x05peers\x18\x01\x20\x03(\x0b2\x05.PeerR\x05peers\"\x84\x01\
    \n\x07KeyPair\x12\x10\n\x03key\x18\x01\x20\x01(\x0cR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\x0cR\x05value\x12\x18\n\x07version\x18\x03\
    \x20\x01(\x04R\x07version\x12\x1d\n\nvalue_type\x18\x04\x20\x01(\tR\tval\
    ueType\x12\x18\n\x07encoded\x18\x06\x20\x01(\x08R\x07encoded\"6\n\x0cKey\
    ValuePair\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\x0cR\x05value\"p\n\tSignature\x12\x1d\n\npublic_key\
    \x18\x01\x20\x01(\x0cR\tpublicKey\x12\x1b\n\tsign_data\x18\x02\x20\x01(\
    \x0cR\x08signData\x12'\n\x0fencryption_type\x18\x03\x20\x01(\tR\x0eencry\
    ptionType\"J\n\tValidator\x12\x18\n\x07address\x18\x01\x20\x01(\tR\x07ad\
    dress\x12#\n\rpledge_amount\x18\x02\x20\x01(\x03R\x0cpledgeAmount\":\n\
    \x0cValidatorSet\x12*\n\nvalidators\x18\x01\x20\x03(\x0b2\n.ValidatorR\n\
    validators\"!\n\tEntryList\x12\x14\n\x05entry\x18\x01\x20\x03(\x0cR\x05e\
    ntry\"\xdb\x02\n\x0cHelloMessage\x12\x1d\n\nnetwork_id\x18\x01\x20\x01(\
    \x04R\tnetworkId\x12%\n\x0eledger_version\x18\x02\x20\x01(\x04R\rledgerV\
    ersion\x12'\n\x0fnetwork_version\x18\x03\x20\x01(\x04R\x0enetworkVersion\
    \x12#\n\rchain_version\x18\x04\x20\x01(\tR\x0cchainVersion\x12%\n\x0elis\
    tening_port\x18\x05\x20\x01(\x03R\rlisteningPort\x12!\n\x0cnode_address\
    \x18\x06\x20\x01(\tR\x0bnodeAddress\x12\x1b\n\tnode_rand\x18\x07\x20\x01\
    (\tR\x08nodeRand\x12\x19\n\x08chain_id\x18\x08\x20\x01(\tR\x07chainId\
    \x12\x1b\n\tchain_hub\x18\t\x20\x01(\tR\x08chainHub\x12\x18\n\x07license\
    \x18\n\x20\x01(\tR\x07license\"V\n\x14HelloResponseMessage\x12#\n\x08err\
    _code\x18\x01\x20\x01(\x0e2\x08.ErrCodeR\x07errCode\x12\x19\n\x08err_des\
    c\x18\x02\x20\x01(\tR\x07errDesc\"\xf5\x01\n\x11TransactionResult\x12\
    \x19\n\x08err_code\x18\x01\x20\x01(\rR\x07errCode\x12\x18\n\x07message\
    \x18\x02\x20\x01(\tR\x07message\x128\n\x0fcontract_result\x18\x03\x20\
    \x01(\x0b2\x0f.ContractResultR\x0econtractResult\x12\x19\n\x08gas_used\
    \x18\x04\x20\x01(\x04R\x07gasUsed\x12!\n\x0cblock_height\x18\x05\x20\x01\
    (\x04R\x0bblockHeight\x12\x1d\n\nblock_hash\x18\x06\x20\x01(\x0cR\tblock\
    Hash\x12\x14\n\x05index\x18\x07\x20\x01(\rR\x05index\"\x94\x01\n\x0eCont\
    ractResult\x12\x19\n\x08err_code\x18\x01\x20\x01(\rR\x07errCode\x12\x16\
    \n\x06result\x18\x02\x20\x01(\x0cR\x06result\x12\x18\n\x07message\x18\
    \x03\x20\x01(\tR\x07message\x125\n\x0econtract_event\x18\x04\x20\x03(\
    \x0b2\x0e.ContractEventR\rcontractEvent\"S\n\rContractEvent\x12\x18\n\
    \x07address\x18\x01\x20\x01(\tR\x07address\x12\x14\n\x05topic\x18\x02\
    \x20\x03(\tR\x05topic\x12\x12\n\x04data\x18\x03\x20\x03(\tR\x04data*F\n\
    \x1aProtocolsActionMessageType\x12\r\n\tBROADCAST\x10\0\x12\x0b\n\x07REQ\
    UEST\x10\x01\x12\x0c\n\x08RESPONSE\x10\x02*\xa9\x01\n\x14ProtocolsMessag\
    eType\x12\x08\n\x04NONE\x10\0\x12\t\n\x05HELLO\x10\x01\x12\x08\n\x04PING\
    \x10\x02\x12\t\n\x05PEERS\x10\x03\x12\x0f\n\x0bTRANSACTION\x10\x04\x12\
    \x0b\n\x07LEDGERS\x10\x05\x12\r\n\tCONSENSUS\x10\x06\x12\x19\n\x15LEDGER\
    _UPGRADE_NOTIFY\x10\x07\x12\t\n\x05LIGHT\x10\x08\x12\x14\n\x10TRANSACTIO\
    N_SYNC\x10\t*\xa6\t\n\x07ErrCode\x12\x13\n\x0fERRCODE_SUCCESS\x10\0\x12\
    \x1d\n\x19ERRCODE_INVALID_PARAMETER\x10\x02\x12\x19\n\x15ERRCODE_ACCESS_\
    DENIED\x10\x06\x12\x19\n\x15ERRCODE_MATH_OVERFLOW\x10\x07\x12\x1a\n\x16E\
    RRCODE_DATABASE_ERROR\x10\x08\x12\x16\n\x12ERRCODE_TRIE_ERROR\x10\t\x12\
    \x1b\n\x17ERRCODE_CREATE_IDENTITY\x10\x1e\x12\x1a\n\x16ERRCODE_INVALID_P\
    UBKEY\x10Z\x12\x1a\n\x16ERRCODE_INVALID_PRIKEY\x10[\x12\x1d\n\x19ERRCODE\
    _INVALID_SIGNATURE\x10]\x12\x1b\n\x17ERRCODE_INVALID_ADDRESS\x10^\x12\
    \x18\n\x14ERRCODE_BAD_SEQUENCE\x10c\x12\x1f\n\x1bERRCODE_ACCOUNT_LOW_RES\
    ERVE\x10d\x12$\n\x20ERRCODE_ACCOUNT_SOURCEDEST_EQUAL\x10e\x12\x1e\n\x1aE\
    RRCODE_ACCOUNT_DEST_EXIST\x10f\x12\x1d\n\x19ERRCODE_ACCOUNT_NOT_EXIST\
    \x10g\x12$\n\x20ERRCODE_ACCOUNT_INIT_LOW_RESERVE\x10j\x12\x1a\n\x16ERRCO\
    DE_FEE_NOT_ENOUGH\x10o\x12\x17\n\x13ERRCODE_FEE_INVALID\x10p\x12\x1a\n\
    \x16ERRCODE_OUT_OF_TXCACHE\x10r\x12\x20\n\x1bERRCODE_INVALID_DATAVERSION\
    \x10\x90\x01\x12\x1c\n\x17ERRCODE_TX_SIZE_TOO_BIG\x10\x92\x01\x12!\n\x1c\
    ERRCODE_CONTRACT_CREATE_FAIL\x10\x96\x01\x12\"\n\x1dERRCODE_CONTRACT_EXE\
    CUTE_FAIL\x10\x97\x01\x12\"\n\x1dERRCODE_CONTRACT_SYNTAX_ERROR\x10\x98\
    \x01\x12(\n#ERRCODE_CONTRACT_TOO_MANY_RECURSION\x10\x99\x01\x12+\n&ERRCO\
    DE_CONTRACT_TOO_MANY_TRANSACTIONS\x10\x9a\x01\x12%\n\x20ERRCODE_CONTRACT\
    _EXECUTE_EXPIRED\x10\x9b\x01\x12$\n\x1fERRCODE_CONTRACT_NO_STATE_ERROR\
    \x10\x9c\x01\x12%\n\x20ERRCODE_CONTRACT_NO_SCHEMA_ERROR\x10\x9d\x01\x12%\
    \n\x20ERRCODE_CONTRACT_PARAMETER_ERROR\x10\x9e\x01\x12'\n\"ERRCODE_CONTR\
    ACT_NO_FUNCTION_ERROR\x10\x9f\x01\x12!\n\x1cERRCODE_TX_INSERT_QUEUE_FAIL\
    \x10\xa0\x01\x12%\n\x20ERRCODE_VALIDATOE_PROPOSAL_ERROR\x10\xa1\x01\x12!\
    \n\x1cERRCODE_VALIDATOE_VOTE_ERROR\x10\xa2\x01\x12\"\n\x1dERRCODE_CONTRA\
    CT_UPDATE_ERROR\x10\xa3\x01J\x984\n\x07\x12\x05\0\0\xb3\x01\x01\n\x08\n\
    \x01\x0c\x12\x03\0\0\x12\n\n\n\x02\x04\0\x12\x04\x02\0\n\x01\n\n\n\x03\
    \x04\0\x01\x12\x03\x02\x08\x18\n\x0b\n\x04\x04\0\x02\0\x12\x03\x03\x02$\
    \n\r\n\x05\x04\0\x02\0\x04\x12\x04\x03\x02\x02\x1a\n\x0c\n\x05\x04\0\x02\
    \0\x06\x12\x03\x03\x02\x16\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x03\x17\
    \x1f\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x03\"#\n\x0b\n\x04\x04\0\x02\
    \x01\x12\x03\x04\x02(\n\r\n\x05\x04\0\x02\x01\x04\x12\x04\x04\x02\x03$\n\
    \x0c\n\x05\x04\0\x02\x01\x06\x12\x03\x04\x02\x1c\n\x0c\n\x05\x04\0\x02\
    \x01\x01\x12\x03\x04\x1d#\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x04&'\n\
    \x0b\n\x04\x04\0\x02\x02\x12\x03\x05\x02\x16\n\r\n\x05\x04\0\x02\x02\x04\
    \x12\x04\x05\x02\x04(\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03\x05\x02\x08\
    \n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x05\t\x11\n\x0c\n\x05\x04\0\x02\
    \x02\x03\x12\x03\x05\x14\x15\n\x0b\n\x04\x04\0\x02\x03\x12\x03\x06\x02\
    \x11\n\r\n\x05\x04\0\x02\x03\x04\x12\x04\x06\x02\x05\x16\n\x0c\n\x05\x04\
    \0\x02\x03\x05\x12\x03\x06\x02\x07\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03\
    \x06\x08\x0c\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\x06\x0f\x10\n\x0b\n\
    \x04\x04\0\x02\x04\x12\x03\x07\x02\x16\n\r\n\x05\x04\0\x02\x04\x04\x12\
    \x04\x07\x02\x06\x11\n\x0c\n\x05\x04\0\x02\x04\x05\x12\x03\x07\x02\x07\n\
    \x0c\n\x05\x04\0\x02\x04\x01\x12\x03\x07\x08\x11\n\x0c\n\x05\x04\0\x02\
    \x04\x03\x12\x03\x07\x14\x15\n\x0b\n\x04\x04\0\x02\x05\x12\x03\x08\x02\
    \x1c\n\x0c\n\x05\x04\0\x02\x05\x04\x12\x03\x08\x02\n\n\x0c\n\x05\x04\0\
    \x02\x05\x05\x12\x03\x08\x0b\x11\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03\
    \x08\x12\x17\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03\x08\x1a\x1b\n\x0b\n\
    \x04\x04\0\x02\x06\x12\x03\t\x02\x12\n\r\n\x05\x04\0\x02\x06\x04\x12\x04\
    \t\x02\x08\x1c\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03\t\x02\x08\n\x0c\n\
    \x05\x04\0\x02\x06\x01\x12\x03\t\t\r\n\x0c\n\x05\x04\0\x02\x06\x03\x12\
    \x03\t\x10\x11\n\n\n\x02\x05\0\x12\x04\x0c\0\x10\x01\n\n\n\x03\x05\0\x01\
    \x12\x03\x0c\x05\x1f\n\x0b\n\x04\x05\0\x02\0\x12\x03\r\x02\x10\n\x0c\n\
    \x05\x05\0\x02\0\x01\x12\x03\r\x02\x0b\n\x0c\n\x05\x05\0\x02\0\x02\x12\
    \x03\r\x0e\x0f\n\x0b\n\x04\x05\0\x02\x01\x12\x03\x0e\x02\x0e\n\x0c\n\x05\
    \x05\0\x02\x01\x01\x12\x03\x0e\x02\t\n\x0c\n\x05\x05\0\x02\x01\x02\x12\
    \x03\x0e\x0c\r\n\x0b\n\x04\x05\0\x02\x02\x12\x03\x0f\x02\x0f\n\x0c\n\x05\
    \x05\0\x02\x02\x01\x12\x03\x0f\x02\n\n\x0c\n\x05\x05\0\x02\x02\x02\x12\
    \x03\x0f\r\x0e\n\n\n\x02\x05\x01\x12\x04\x12\0\x1d\x01\n\n\n\x03\x05\x01\
    \x01\x12\x03\x12\x05\x19\n\x0b\n\x04\x05\x01\x02\0\x12\x03\x13\x02\x0b\n\
    \x0c\n\x05\x05\x01\x02\0\x01\x12\x03\x13\x02\x06\n\x0c\n\x05\x05\x01\x02\
    \0\x02\x12\x03\x13\t\n\n\x0b\n\x04\x05\x01\x02\x01\x12\x03\x14\x02\x0c\n\
    \x0c\n\x05\x05\x01\x02\x01\x01\x12\x03\x14\x02\x07\n\x0c\n\x05\x05\x01\
    \x02\x01\x02\x12\x03\x14\n\x0b\n\x0b\n\x04\x05\x01\x02\x02\x12\x03\x15\
    \x02\x0b\n\x0c\n\x05\x05\x01\x02\x02\x01\x12\x03\x15\x02\x06\n\x0c\n\x05\
    \x05\x01\x02\x02\x02\x12\x03\x15\t\n\n\x0b\n\x04\x05\x01\x02\x03\x12\x03\
    \x16\x02\x0c\n\x0c\n\x05\x05\x01\x02\x03\x01\x12\x03\x16\x02\x07\n\x0c\n\
    \x05\x05\x01\x02\x03\x02\x12\x03\x16\n\x0b\n\x0b\n\x04\x05\x01\x02\x04\
    \x12\x03\x17\x02\x12\n\x0c\n\x05\x05\x01\x02\x04\x01\x12\x03\x17\x02\r\n\
    \x0c\n\x05\x05\x01\x02\x04\x02\x12\x03\x17\x10\x11\n\x0b\n\x04\x05\x01\
    \x02\x05\x12\x03\x18\x02\x0e\n\x0c\n\x05\x05\x01\x02\x05\x01\x12\x03\x18\
    \x02\t\n\x0c\n\x05\x05\x01\x02\x05\x02\x12\x03\x18\x0c\r\n\x0b\n\x04\x05\
    \x01\x02\x06\x12\x03\x19\x02\x10\n\x0c\n\x05\x05\x01\x02\x06\x01\x12\x03\
    \x19\x02\x0b\n\x0c\n\x05\x05\x01\x02\x06\x02\x12\x03\x19\x0e\x0f\n\x0b\n\
    \x04\x05\x01\x02\x07\x12\x03\x1a\x02\x1c\n\x0c\n\x05\x05\x01\x02\x07\x01\
    \x12\x03\x1a\x02\x17\n\x0c\n\x05\x05\x01\x02\x07\x02\x12\x03\x1a\x1a\x1b\
    \n\x0b\n\x04\x05\x01\x02\x08\x12\x03\x1b\x02\x0c\n\x0c\n\x05\x05\x01\x02\
    \x08\x01\x12\x03\x1b\x02\x07\n\x0c\n\x05\x05\x01\x02\x08\x02\x12\x03\x1b\
    \n\x0b\n\x0b\n\x04\x05\x01\x02\t\x12\x03\x1c\x02\x17\n\x0c\n\x05\x05\x01\
    \x02\t\x01\x12\x03\x1c\x02\x12\n\x0c\n\x05\x05\x01\x02\t\x02\x12\x03\x1c\
    \x15\x16\n\x1e\n\x02\x04\x01\x12\x04\x20\0\"\x01\x1a\x12for\x20ping\x20m\
    esssage\n\n\n\n\x03\x04\x01\x01\x12\x03\x20\x08\x0c\n\x0b\n\x04\x04\x01\
    \x02\0\x12\x03!\x02\x12\n\r\n\x05\x04\x01\x02\0\x04\x12\x04!\x02\x20\x0e\
    \n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03!\x02\x07\n\x0c\n\x05\x04\x01\x02\
    \0\x01\x12\x03!\x08\r\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03!\x10\x11\n\
    \x1d\n\x02\x04\x02\x12\x04%\0'\x01\x1a\x11for\x20pong\x20message\n\n\n\n\
    \x03\x04\x02\x01\x12\x03%\x08\x0c\n\x0b\n\x04\x04\x02\x02\0\x12\x03&\x02\
    \x12\n\r\n\x05\x04\x02\x02\0\x04\x12\x04&\x02%\x0e\n\x0c\n\x05\x04\x02\
    \x02\0\x05\x12\x03&\x02\x07\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03&\x08\r\
    \n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03&\x10\x11\n\x1e\n\x02\x04\x03\x12\
    \x04*\00\x01\x1a\x12for\x20peers\x20message\n\n\n\n\x03\x04\x03\x01\x12\
    \x03*\x08\x0c\n\x0b\n\x04\x04\x03\x02\0\x12\x03+\x02\x15\n\r\n\x05\x04\
    \x03\x02\0\x04\x12\x04+\x02*\x0e\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03+\
    \x02\x08\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03+\t\x10\n\x0c\n\x05\x04\
    \x03\x02\0\x03\x12\x03+\x13\x14\n\x0b\n\x04\x04\x03\x02\x01\x12\x03,\x02\
    \x19\n\r\n\x05\x04\x03\x02\x01\x04\x12\x04,\x02+\x15\n\x0c\n\x05\x04\x03\
    \x02\x01\x05\x12\x03,\x02\x07\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03,\
    \x08\x14\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03,\x17\x18\n\x0b\n\x04\
    \x04\x03\x02\x02\x12\x03-\x02\x1d\n\r\n\x05\x04\x03\x02\x02\x04\x12\x04-\
    \x02,\x19\n\x0c\n\x05\x04\x03\x02\x02\x05\x12\x03-\x02\x07\n\x0c\n\x05\
    \x04\x03\x02\x02\x01\x12\x03-\x08\x19\n\x0c\n\x05\x04\x03\x02\x02\x03\
    \x12\x03-\x1b\x1c\n\x0b\n\x04\x04\x03\x02\x03\x12\x03.\x02\x18\n\r\n\x05\
    \x04\x03\x02\x03\x04\x12\x04.\x02-\x1d\n\x0c\n\x05\x04\x03\x02\x03\x05\
    \x12\x03.\x02\x07\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\x03.\x08\x13\n\x0c\
    \n\x05\x04\x03\x02\x03\x03\x12\x03.\x16\x17\n\x0b\n\x04\x04\x03\x02\x04\
    \x12\x03/\x02\x19\n\r\n\x05\x04\x03\x02\x04\x04\x12\x04/\x02.\x18\n\x0c\
    \n\x05\x04\x03\x02\x04\x05\x12\x03/\x02\x07\n\x0c\n\x05\x04\x03\x02\x04\
    \x01\x12\x03/\x08\x15\n\x0c\n\x05\x04\x03\x02\x04\x03\x12\x03/\x17\x18\n\
    \n\n\x02\x04\x04\x12\x042\04\x01\n\n\n\x03\x04\x04\x01\x12\x032\x08\r\n\
    \x0b\n\x04\x04\x04\x02\0\x12\x033\x02\x1a\n\x0c\n\x05\x04\x04\x02\0\x04\
    \x12\x033\x02\n\n\x0c\n\x05\x04\x04\x02\0\x06\x12\x033\x0b\x0f\n\x0c\n\
    \x05\x04\x04\x02\0\x01\x12\x033\x10\x15\n\x0c\n\x05\x04\x04\x02\0\x03\
    \x12\x033\x18\x19\n\n\n\x02\x04\x05\x12\x046\0<\x01\n\n\n\x03\x04\x05\
    \x01\x12\x036\x08\x0f\n\x0b\n\x04\x04\x05\x02\0\x12\x037\x08\x16\n\r\n\
    \x05\x04\x05\x02\0\x04\x12\x047\x086\x10\n\x0c\n\x05\x04\x05\x02\0\x05\
    \x12\x037\x08\r\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x037\x0e\x11\n\x0c\n\
    \x05\x04\x05\x02\0\x03\x12\x037\x14\x15\n\x0b\n\x04\x04\x05\x02\x01\x12\
    \x038\x08\x18\n\r\n\x05\x04\x05\x02\x01\x04\x12\x048\x087\x16\n\x0c\n\
    \x05\x04\x05\x02\x01\x05\x12\x038\x08\r\n\x0c\n\x05\x04\x05\x02\x01\x01\
    \x12\x038\x0e\x13\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x038\x16\x17\n\x0b\
    \n\x04\x04\x05\x02\x02\x12\x039\x08\x1b\n\r\n\x05\x04\x05\x02\x02\x04\
    \x12\x049\x088\x18\n\x0c\n\x05\x04\x05\x02\x02\x05\x12\x039\x08\x0e\n\
    \x0c\n\x05\x04\x05\x02\x02\x01\x12\x039\x0f\x16\n\x0c\n\x05\x04\x05\x02\
    \x02\x03\x12\x039\x19\x1a\n\x0b\n\x04\x04\x05\x02\x03\x12\x03:\x02\x18\n\
    \r\n\x05\x04\x05\x02\x03\x04\x12\x04:\x029\x1b\n\x0c\n\x05\x04\x05\x02\
    \x03\x05\x12\x03:\x02\x08\n\x0c\n\x05\x04\x05\x02\x03\x01\x12\x03:\t\x13\
    \n\x0c\n\x05\x04\x05\x02\x03\x03\x12\x03:\x16\x17\n\x0b\n\x04\x04\x05\
    \x02\x04\x12\x03;\x02\x12\n\r\n\x05\x04\x05\x02\x04\x04\x12\x04;\x02:\
    \x18\n\x0c\n\x05\x04\x05\x02\x04\x05\x12\x03;\x02\x06\n\x0c\n\x05\x04\
    \x05\x02\x04\x01\x12\x03;\x07\x0e\n\x0c\n\x05\x04\x05\x02\x04\x03\x12\
    \x03;\x10\x11\n\n\n\x02\x04\x06\x12\x04>\0A\x01\n\n\n\x03\x04\x06\x01\
    \x12\x03>\x08\x14\n\x0b\n\x04\x04\x06\x02\0\x12\x03?\x02\x11\n\r\n\x05\
    \x04\x06\x02\0\x04\x12\x04?\x02>\x16\n\x0c\n\x05\x04\x06\x02\0\x05\x12\
    \x03?\x02\x08\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03?\t\x0c\n\x0c\n\x05\
    \x04\x06\x02\0\x03\x12\x03?\x0f\x10\n\x0b\n\x04\x04\x06\x02\x01\x12\x03@\
    \x02\x12\n\r\n\x05\x04\x06\x02\x01\x04\x12\x04@\x02?\x11\n\x0c\n\x05\x04\
    \x06\x02\x01\x05\x12\x03@\x02\x07\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\
    \x03@\x08\r\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03@\x10\x11\n\n\n\x02\
    \x04\x07\x12\x04C\0G\x01\n\n\n\x03\x04\x07\x01\x12\x03C\x08\x11\n\x0b\n\
    \x04\x04\x07\x02\0\x12\x03D\x02\x17\n\r\n\x05\x04\x07\x02\0\x04\x12\x04D\
    \x02C\x13\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03D\x02\x07\n\x0c\n\x05\x04\
    \x07\x02\0\x01\x12\x03D\x08\x12\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03D\
    \x15\x16\n\x0b\n\x04\x04\x07\x02\x01\x12\x03E\x02\x16\n\r\n\x05\x04\x07\
    \x02\x01\x04\x12\x04E\x02D\x17\n\x0c\n\x05\x04\x07\x02\x01\x05\x12\x03E\
    \x02\x07\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03E\x08\x11\n\x0c\n\x05\
    \x04\x07\x02\x01\x03\x12\x03E\x14\x15\n\x0b\n\x04\x04\x07\x02\x02\x12\
    \x03F\x02\x1d\n\r\n\x05\x04\x07\x02\x02\x04\x12\x04F\x02E\x16\n\x0c\n\
    \x05\x04\x07\x02\x02\x05\x12\x03F\x02\x08\n\x0c\n\x05\x04\x07\x02\x02\
    \x01\x12\x03F\t\x18\n\x0c\n\x05\x04\x07\x02\x02\x03\x12\x03F\x1b\x1c\n\n\
    \n\x02\x04\x08\x12\x04I\0L\x01\n\n\n\x03\x04\x08\x01\x12\x03I\x08\x11\n\
    \x0b\n\x04\x04\x08\x02\0\x12\x03J\x02\x15\n\r\n\x05\x04\x08\x02\0\x04\
    \x12\x04J\x02I\x13\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x03J\x02\x08\n\x0c\
    \n\x05\x04\x08\x02\0\x01\x12\x03J\t\x10\n\x0c\n\x05\x04\x08\x02\0\x03\
    \x12\x03J\x13\x14\n\x0b\n\x04\x04\x08\x02\x01\x12\x03K\x02\x1a\n\r\n\x05\
    \x04\x08\x02\x01\x04\x12\x04K\x02J\x15\n\x0c\n\x05\x04\x08\x02\x01\x05\
    \x12\x03K\x02\x07\n\x0c\n\x05\x04\x08\x02\x01\x01\x12\x03K\x08\x15\n\x0c\
    \n\x05\x04\x08\x02\x01\x03\x12\x03K\x18\x19\n\n\n\x02\x04\t\x12\x04N\0P\
    \x01\n\n\n\x03\x04\t\x01\x12\x03N\x08\x14\n\x0b\n\x04\x04\t\x02\0\x12\
    \x03O\x02$\n\x0c\n\x05\x04\t\x02\0\x04\x12\x03O\x02\n\n\x0c\n\x05\x04\t\
    \x02\0\x06\x12\x03O\x0b\x14\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03O\x15\x1f\
    \n\x0c\n\x05\x04\t\x02\0\x03\x12\x03O\"#\n%\n\x02\x04\n\x12\x04S\0U\x01\
    \x1a\x19for\x20key\x20value\x20db\x20storage\n\n\n\n\x03\x04\n\x01\x12\
    \x03S\x08\x11\n\x0b\n\x04\x04\n\x02\0\x12\x03T\x08!\n\x0c\n\x05\x04\n\
    \x02\0\x04\x12\x03T\x08\x10\n\x0c\n\x05\x04\n\x02\0\x05\x12\x03T\x11\x16\
    \n\x0c\n\x05\x04\n\x02\0\x01\x12\x03T\x17\x1c\n\x0c\n\x05\x04\n\x02\0\
    \x03\x12\x03T\x1f\x20\n\x0b\n\x02\x05\x02\x12\x05W\0\x87\x01\x01\n\n\n\
    \x03\x05\x02\x01\x12\x03W\x05\x0c\n\x0b\n\x04\x05\x02\x02\0\x12\x03Y\x02\
    \x16\n\x0c\n\x05\x05\x02\x02\0\x01\x12\x03Y\x02\x11\n\x0c\n\x05\x05\x02\
    \x02\0\x02\x12\x03Y\x14\x15\n\x0b\n\x04\x05\x02\x02\x01\x12\x03Z\x02\x20\
    \n\x0c\n\x05\x05\x02\x02\x01\x01\x12\x03Z\x02\x1b\n\x0c\n\x05\x05\x02\
    \x02\x01\x02\x12\x03Z\x1e\x1f\n\x0b\n\x04\x05\x02\x02\x02\x12\x03[\x02\
    \x1c\n\x0c\n\x05\x05\x02\x02\x02\x01\x12\x03[\x02\x17\n\x0c\n\x05\x05\
    \x02\x02\x02\x02\x12\x03[\x1a\x1b\n\x0b\n\x04\x05\x02\x02\x03\x12\x03\\\
    \x02\x1c\n\x0c\n\x05\x05\x02\x02\x03\x01\x12\x03\\\x02\x17\n\x0c\n\x05\
    \x05\x02\x02\x03\x02\x12\x03\\\x1a\x1b\n\x0b\n\x04\x05\x02\x02\x04\x12\
    \x03^\x02\x1d\n\x0c\n\x05\x05\x02\x02\x04\x01\x12\x03^\x02\x18\n\x0c\n\
    \x05\x05\x02\x02\x04\x02\x12\x03^\x1b\x1c\n\x0b\n\x04\x05\x02\x02\x05\
    \x12\x03_\x02\x19\n\x0c\n\x05\x05\x02\x02\x05\x01\x12\x03_\x02\x14\n\x0c\
    \n\x05\x05\x02\x02\x05\x02\x12\x03_\x17\x18\n\x0b\n\x04\x05\x02\x02\x06\
    \x12\x03a\x02\x1f\n\x0c\n\x05\x05\x02\x02\x06\x01\x12\x03a\x02\x19\n\x0c\
    \n\x05\x05\x02\x02\x06\x02\x12\x03a\x1c\x1e\n\x15\n\x04\x05\x02\x02\x07\
    \x12\x03c\x02\x1e\"\x08\x20UNUSED\n\n\x0c\n\x05\x05\x02\x02\x07\x01\x12\
    \x03c\x02\x18\n\x0c\n\x05\x05\x02\x02\x07\x02\x12\x03c\x1b\x1d\n\x0b\n\
    \x04\x05\x02\x02\x08\x12\x03d\x02\x1e\n\x0c\n\x05\x05\x02\x02\x08\x01\
    \x12\x03d\x02\x18\n\x0c\n\x05\x05\x02\x02\x08\x02\x12\x03d\x1b\x1d\n\x0b\
    \n\x04\x05\x02\x02\t\x12\x03e\x02!\n\x0c\n\x05\x05\x02\x02\t\x01\x12\x03\
    e\x02\x1b\n\x0c\n\x05\x05\x02\x02\t\x02\x12\x03e\x1e\x20\n\x0b\n\x04\x05\
    \x02\x02\n\x12\x03f\x02\x1f\n\x0c\n\x05\x05\x02\x02\n\x01\x12\x03f\x02\
    \x19\n\x0c\n\x05\x05\x02\x02\n\x02\x12\x03f\x1c\x1e\n\x0b\n\x04\x05\x02\
    \x02\x0b\x12\x03h\x02\x1c\n\x0c\n\x05\x05\x02\x02\x0b\x01\x12\x03h\x02\
    \x16\n\x0c\n\x05\x05\x02\x02\x0b\x02\x12\x03h\x19\x1b\n\x0b\n\x04\x05\
    \x02\x02\x0c\x12\x03i\x02$\n\x0c\n\x05\x05\x02\x02\x0c\x01\x12\x03i\x02\
    \x1d\n\x0c\n\x05\x05\x02\x02\x0c\x02\x12\x03i\x20#\n\x0b\n\x04\x05\x02\
    \x02\r\x12\x03j\x02)\n\x0c\n\x05\x05\x02\x02\r\x01\x12\x03j\x02\"\n\x0c\
    \n\x05\x05\x02\x02\r\x02\x12\x03j%(\n\x0b\n\x04\x05\x02\x02\x0e\x12\x03k\
    \x02#\n\x0c\n\x05\x05\x02\x02\x0e\x01\x12\x03k\x02\x1c\n\x0c\n\x05\x05\
    \x02\x02\x0e\x02\x12\x03k\x1f\"\n\x0b\n\x04\x05\x02\x02\x0f\x12\x03l\x02\
    \"\n\x0c\n\x05\x05\x02\x02\x0f\x01\x12\x03l\x02\x1b\n\x0c\n\x05\x05\x02\
    \x02\x0f\x02\x12\x03l\x1e!\n\x0b\n\x04\x05\x02\x02\x10\x12\x03m\x02)\n\
    \x0c\n\x05\x05\x02\x02\x10\x01\x12\x03m\x02\"\n\x0c\n\x05\x05\x02\x02\
    \x10\x02\x12\x03m%(\n\x0b\n\x04\x05\x02\x02\x11\x12\x03o\x02\x1f\n\x0c\n\
    \x05\x05\x02\x02\x11\x01\x12\x03o\x02\x18\n\x0c\n\x05\x05\x02\x02\x11\
    \x02\x12\x03o\x1b\x1e\n\x0b\n\x04\x05\x02\x02\x12\x12\x03p\x02\x1c\n\x0c\
    \n\x05\x05\x02\x02\x12\x01\x12\x03p\x02\x15\n\x0c\n\x05\x05\x02\x02\x12\
    \x02\x12\x03p\x18\x1b\n\x0b\n\x04\x05\x02\x02\x13\x12\x03q\x02\x1f\n\x0c\
    \n\x05\x05\x02\x02\x13\x01\x12\x03q\x02\x18\n\x0c\n\x05\x05\x02\x02\x13\
    \x02\x12\x03q\x1b\x1e\n\x0b\n\x04\x05\x02\x02\x14\x12\x03t\x02$\n\x0c\n\
    \x05\x05\x02\x02\x14\x01\x12\x03t\x02\x1d\n\x0c\n\x05\x05\x02\x02\x14\
    \x02\x12\x03t\x20#\n\x0b\n\x04\x05\x02\x02\x15\x12\x03u\x02\x20\n\x0c\n\
    \x05\x05\x02\x02\x15\x01\x12\x03u\x02\x19\n\x0c\n\x05\x05\x02\x02\x15\
    \x02\x12\x03u\x1c\x1f\n\x0b\n\x04\x05\x02\x02\x16\x12\x03w\x02%\n\x0c\n\
    \x05\x05\x02\x02\x16\x01\x12\x03w\x02\x1e\n\x0c\n\x05\x05\x02\x02\x16\
    \x02\x12\x03w!$\n\x0b\n\x04\x05\x02\x02\x17\x12\x03x\x02&\n\x0c\n\x05\
    \x05\x02\x02\x17\x01\x12\x03x\x02\x1f\n\x0c\n\x05\x05\x02\x02\x17\x02\
    \x12\x03x\"%\n\x0b\n\x04\x05\x02\x02\x18\x12\x03y\x02&\n\x0c\n\x05\x05\
    \x02\x02\x18\x01\x12\x03y\x02\x1f\n\x0c\n\x05\x05\x02\x02\x18\x02\x12\
    \x03y\"%\n\x0b\n\x04\x05\x02\x02\x19\x12\x03z\x02,\n\x0c\n\x05\x05\x02\
    \x02\x19\x01\x12\x03z\x02%\n\x0c\n\x05\x05\x02\x02\x19\x02\x12\x03z(+\n\
    \x0b\n\x04\x05\x02\x02\x1a\x12\x03{\x02/\n\x0c\n\x05\x05\x02\x02\x1a\x01\
    \x12\x03{\x02(\n\x0c\n\x05\x05\x02\x02\x1a\x02\x12\x03{+.\n\x0b\n\x04\
    \x05\x02\x02\x1b\x12\x03|\x02)\n\x0c\n\x05\x05\x02\x02\x1b\x01\x12\x03|\
    \x02\"\n\x0c\n\x05\x05\x02\x02\x1b\x02\x12\x03|%(\n\x0b\n\x04\x05\x02\
    \x02\x1c\x12\x03}\x02(\n\x0c\n\x05\x05\x02\x02\x1c\x01\x12\x03}\x02!\n\
    \x0c\n\x05\x05\x02\x02\x1c\x02\x12\x03}$'\n\x0b\n\x04\x05\x02\x02\x1d\
    \x12\x03~\x02)\n\x0c\n\x05\x05\x02\x02\x1d\x01\x12\x03~\x02\"\n\x0c\n\
    \x05\x05\x02\x02\x1d\x02\x12\x03~%(\n\x0b\n\x04\x05\x02\x02\x1e\x12\x03\
    \x7f\x02'\n\x0c\n\x05\x05\x02\x02\x1e\x01\x12\x03\x7f\x02\"\n\x0c\n\x05\
    \x05\x02\x02\x1e\x02\x12\x03\x7f#&\n\x0c\n\x04\x05\x02\x02\x1f\x12\x04\
    \x80\x01\x02)\n\r\n\x05\x05\x02\x02\x1f\x01\x12\x04\x80\x01\x02$\n\r\n\
    \x05\x05\x02\x02\x1f\x02\x12\x04\x80\x01%(\n\x0c\n\x04\x05\x02\x02\x20\
    \x12\x04\x82\x01\x02%\n\r\n\x05\x05\x02\x02\x20\x01\x12\x04\x82\x01\x02\
    \x1e\n\r\n\x05\x05\x02\x02\x20\x02\x12\x04\x82\x01!$\n\x0c\n\x04\x05\x02\
    \x02!\x12\x04\x84\x01\x02)\n\r\n\x05\x05\x02\x02!\x01\x12\x04\x84\x01\
    \x02\"\n\r\n\x05\x05\x02\x02!\x02\x12\x04\x84\x01%(\n\x0c\n\x04\x05\x02\
    \x02\"\x12\x04\x85\x01\x02%\n\r\n\x05\x05\x02\x02\"\x01\x12\x04\x85\x01\
    \x02\x1e\n\r\n\x05\x05\x02\x02\"\x02\x12\x04\x85\x01!$\n\x0c\n\x04\x05\
    \x02\x02#\x12\x04\x86\x01\x02$\n\r\n\x05\x05\x02\x02#\x01\x12\x04\x86\
    \x01\x02\x1f\n\r\n\x05\x05\x02\x02#\x02\x12\x04\x86\x01\x20#\n\x0c\n\x02\
    \x04\x0b\x12\x06\x89\x01\0\x94\x01\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\
    \x89\x01\x08\x14\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\x8a\x01\x02\x18\n\x0f\
    \n\x05\x04\x0b\x02\0\x04\x12\x06\x8a\x01\x02\x89\x01\x16\n\r\n\x05\x04\
    \x0b\x02\0\x05\x12\x04\x8a\x01\x02\x08\n\r\n\x05\x04\x0b\x02\0\x01\x12\
    \x04\x8a\x01\t\x13\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\x8a\x01\x16\x17\n\
    \x0c\n\x04\x04\x0b\x02\x01\x12\x04\x8b\x01\x02\x1c\n\x0f\n\x05\x04\x0b\
    \x02\x01\x04\x12\x06\x8b\x01\x02\x8a\x01\x18\n\r\n\x05\x04\x0b\x02\x01\
    \x05\x12\x04\x8b\x01\x02\x08\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\x8b\
    \x01\t\x17\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\x8b\x01\x1a\x1b\n\x0c\n\
    \x04\x04\x0b\x02\x02\x12\x04\x8c\x01\x02\x1d\n\x0f\n\x05\x04\x0b\x02\x02\
    \x04\x12\x06\x8c\x01\x02\x8b\x01\x1c\n\r\n\x05\x04\x0b\x02\x02\x05\x12\
    \x04\x8c\x01\x02\x08\n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\x8c\x01\t\x18\
    \n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\x8c\x01\x1b\x1c\n\x0c\n\x04\x04\
    \x0b\x02\x03\x12\x04\x8d\x01\x02\x1b\n\x0f\n\x05\x04\x0b\x02\x03\x04\x12\
    \x06\x8d\x01\x02\x8c\x01\x1d\n\r\n\x05\x04\x0b\x02\x03\x05\x12\x04\x8d\
    \x01\x02\x08\n\r\n\x05\x04\x0b\x02\x03\x01\x12\x04\x8d\x01\t\x16\n\r\n\
    \x05\x04\x0b\x02\x03\x03\x12\x04\x8d\x01\x19\x1a\n\x0c\n\x04\x04\x0b\x02\
    \x04\x12\x04\x8e\x01\x02\x1b\n\x0f\n\x05\x04\x0b\x02\x04\x04\x12\x06\x8e\
    \x01\x02\x8d\x01\x1b\n\r\n\x05\x04\x0b\x02\x04\x05\x12\x04\x8e\x01\x02\
    \x07\n\r\n\x05\x04\x0b\x02\x04\x01\x12\x04\x8e\x01\x08\x16\n\r\n\x05\x04\
    \x0b\x02\x04\x03\x12\x04\x8e\x01\x19\x1a\n\x0c\n\x04\x04\x0b\x02\x05\x12\
    \x04\x8f\x01\x02\x1a\n\x0f\n\x05\x04\x0b\x02\x05\x04\x12\x06\x8f\x01\x02\
    \x8e\x01\x1b\n\r\n\x05\x04\x0b\x02\x05\x05\x12\x04\x8f\x01\x02\x08\n\r\n\
    \x05\x04\x0b\x02\x05\x01\x12\x04\x8f\x01\t\x15\n\r\n\x05\x04\x0b\x02\x05\
    \x03\x12\x04\x8f\x01\x18\x19\n\x0c\n\x04\x04\x0b\x02\x06\x12\x04\x90\x01\
    \x02\x17\n\x0f\n\x05\x04\x0b\x02\x06\x04\x12\x06\x90\x01\x02\x8f\x01\x1a\
    \n\r\n\x05\x04\x0b\x02\x06\x05\x12\x04\x90\x01\x02\x08\n\r\n\x05\x04\x0b\
    \x02\x06\x01\x12\x04\x90\x01\t\x12\n\r\n\x05\x04\x0b\x02\x06\x03\x12\x04\
    \x90\x01\x15\x16\n\x0c\n\x04\x04\x0b\x02\x07\x12\x04\x91\x01\x02\x16\n\
    \x0f\n\x05\x04\x0b\x02\x07\x04\x12\x06\x91\x01\x02\x90\x01\x17\n\r\n\x05\
    \x04\x0b\x02\x07\x05\x12\x04\x91\x01\x02\x08\n\r\n\x05\x04\x0b\x02\x07\
    \x01\x12\x04\x91\x01\t\x11\n\r\n\x05\x04\x0b\x02\x07\x03\x12\x04\x91\x01\
    \x14\x15\n\x0c\n\x04\x04\x0b\x02\x08\x12\x04\x92\x01\x02\x17\n\x0f\n\x05\
    \x04\x0b\x02\x08\x04\x12\x06\x92\x01\x02\x91\x01\x16\n\r\n\x05\x04\x0b\
    \x02\x08\x05\x12\x04\x92\x01\x02\x08\n\r\n\x05\x04\x0b\x02\x08\x01\x12\
    \x04\x92\x01\t\x12\n\r\n\x05\x04\x0b\x02\x08\x03\x12\x04\x92\x01\x15\x16\
    \n\x0c\n\x04\x04\x0b\x02\t\x12\x04\x93\x01\x02\x16\n\x0f\n\x05\x04\x0b\
    \x02\t\x04\x12\x06\x93\x01\x02\x92\x01\x17\n\r\n\x05\x04\x0b\x02\t\x05\
    \x12\x04\x93\x01\x02\x08\n\r\n\x05\x04\x0b\x02\t\x01\x12\x04\x93\x01\t\
    \x10\n\r\n\x05\x04\x0b\x02\t\x03\x12\x04\x93\x01\x13\x15\n\x0c\n\x02\x04\
    \x0c\x12\x06\x96\x01\0\x99\x01\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\x96\
    \x01\x08\x1c\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\x97\x01\x02\x17\n\x0f\n\
    \x05\x04\x0c\x02\0\x04\x12\x06\x97\x01\x02\x96\x01\x1e\n\r\n\x05\x04\x0c\
    \x02\0\x06\x12\x04\x97\x01\x02\t\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\x97\
    \x01\n\x12\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\x97\x01\x15\x16\n\x0c\n\
    \x04\x04\x0c\x02\x01\x12\x04\x98\x01\x02\x16\n\x0f\n\x05\x04\x0c\x02\x01\
    \x04\x12\x06\x98\x01\x02\x97\x01\x17\n\r\n\x05\x04\x0c\x02\x01\x05\x12\
    \x04\x98\x01\x02\x08\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\x98\x01\t\x11\
    \n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\x98\x01\x14\x15\n\x0c\n\x02\x04\r\
    \x12\x06\x9c\x01\0\xa4\x01\x01\n\x0b\n\x03\x04\r\x01\x12\x04\x9c\x01\x08\
    \x19\n\x0c\n\x04\x04\r\x02\0\x12\x04\x9d\x01\x02\x16\n\x0f\n\x05\x04\r\
    \x02\0\x04\x12\x06\x9d\x01\x02\x9c\x01\x1b\n\r\n\x05\x04\r\x02\0\x05\x12\
    \x04\x9d\x01\x02\x08\n\r\n\x05\x04\r\x02\0\x01\x12\x04\x9d\x01\t\x11\n\r\
    \n\x05\x04\r\x02\0\x03\x12\x04\x9d\x01\x14\x15\n\x0c\n\x04\x04\r\x02\x01\
    \x12\x04\x9e\x01\x02\x15\n\x0f\n\x05\x04\r\x02\x01\x04\x12\x06\x9e\x01\
    \x02\x9d\x01\x16\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\x9e\x01\x02\x08\n\r\
    \n\x05\x04\r\x02\x01\x01\x12\x04\x9e\x01\t\x10\n\r\n\x05\x04\r\x02\x01\
    \x03\x12\x04\x9e\x01\x13\x14\n\x0c\n\x04\x04\r\x02\x02\x12\x04\x9f\x01\
    \x02%\n\x0f\n\x05\x04\r\x02\x02\x04\x12\x06\x9f\x01\x02\x9e\x01\x15\n\r\
    \n\x05\x04\r\x02\x02\x06\x12\x04\x9f\x01\x02\x10\n\r\n\x05\x04\r\x02\x02\
    \x01\x12\x04\x9f\x01\x11\x20\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\x9f\x01\
    #$\n\x0c\n\x04\x04\r\x02\x03\x12\x04\xa0\x01\x02\x16\n\x0f\n\x05\x04\r\
    \x02\x03\x04\x12\x06\xa0\x01\x02\x9f\x01%\n\r\n\x05\x04\r\x02\x03\x05\
    \x12\x04\xa0\x01\x02\x08\n\r\n\x05\x04\r\x02\x03\x01\x12\x04\xa0\x01\t\
    \x11\n\r\n\x05\x04\r\x02\x03\x03\x12\x04\xa0\x01\x14\x15\n\x0c\n\x04\x04\
    \r\x02\x04\x12\x04\xa1\x01\x02\x1a\n\x0f\n\x05\x04\r\x02\x04\x04\x12\x06\
    \xa1\x01\x02\xa0\x01\x16\n\r\n\x05\x04\r\x02\x04\x05\x12\x04\xa1\x01\x02\
    \x08\n\r\n\x05\x04\r\x02\x04\x01\x12\x04\xa1\x01\t\x15\n\r\n\x05\x04\r\
    \x02\x04\x03\x12\x04\xa1\x01\x18\x19\n\x0c\n\x04\x04\r\x02\x05\x12\x04\
    \xa2\x01\x02\x18\n\x0f\n\x05\x04\r\x02\x05\x04\x12\x06\xa2\x01\x02\xa1\
    \x01\x1a\n\r\n\x05\x04\r\x02\x05\x05\x12\x04\xa2\x01\x02\x07\n\r\n\x05\
    \x04\r\x02\x05\x01\x12\x04\xa2\x01\t\x13\n\r\n\x05\x04\r\x02\x05\x03\x12\
    \x04\xa2\x01\x16\x17\n\x0c\n\x04\x04\r\x02\x06\x12\x04\xa3\x01\x02\x13\n\
    \x0f\n\x05\x04\r\x02\x06\x04\x12\x06\xa3\x01\x02\xa2\x01\x18\n\r\n\x05\
    \x04\r\x02\x06\x05\x12\x04\xa3\x01\x02\x08\n\r\n\x05\x04\r\x02\x06\x01\
    \x12\x04\xa3\x01\t\x0e\n\r\n\x05\x04\r\x02\x06\x03\x12\x04\xa3\x01\x11\
    \x12\n\x0c\n\x02\x04\x0e\x12\x06\xa6\x01\0\xab\x01\x01\n\x0b\n\x03\x04\
    \x0e\x01\x12\x04\xa6\x01\x08\x16\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\xa7\
    \x01\x02\x16\n\x0f\n\x05\x04\x0e\x02\0\x04\x12\x06\xa7\x01\x02\xa6\x01\
    \x18\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\xa7\x01\x02\x08\n\r\n\x05\x04\
    \x0e\x02\0\x01\x12\x04\xa7\x01\t\x11\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\
    \xa7\x01\x14\x15\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\xa8\x01\x02\x13\n\
    \x0f\n\x05\x04\x0e\x02\x01\x04\x12\x06\xa8\x01\x02\xa7\x01\x16\n\r\n\x05\
    \x04\x0e\x02\x01\x05\x12\x04\xa8\x01\x02\x07\n\r\n\x05\x04\x0e\x02\x01\
    \x01\x12\x04\xa8\x01\x08\x0e\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xa8\
    \x01\x11\x12\n\x0c\n\x04\x04\x0e\x02\x02\x12\x04\xa9\x01\x02\x15\n\x0f\n\
    \x05\x04\x0e\x02\x02\x04\x12\x06\xa9\x01\x02\xa8\x01\x13\n\r\n\x05\x04\
    \x0e\x02\x02\x05\x12\x04\xa9\x01\x02\x08\n\r\n\x05\x04\x0e\x02\x02\x01\
    \x12\x04\xa9\x01\t\x10\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\xa9\x01\x13\
    \x14\n\x0c\n\x04\x04\x0e\x02\x03\x12\x04\xaa\x01\x02,\n\r\n\x05\x04\x0e\
    \x02\x03\x04\x12\x04\xaa\x01\x02\n\n\r\n\x05\x04\x0e\x02\x03\x06\x12\x04\
    \xaa\x01\x0b\x18\n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\xaa\x01\x19'\n\r\
    \n\x05\x04\x0e\x02\x03\x03\x12\x04\xaa\x01*+\n3\n\x02\x04\x0f\x12\x06\
    \xae\x01\0\xb3\x01\x01\x1a%\x20contract\x20event\x20saved\x20in\x20block\
    \x20chain\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\xae\x01\x08\x15\n.\n\x04\x04\
    \x0f\x02\0\x12\x04\xb0\x01\x02\x16\x1a\x20\x20contract\x20that\x20emitte\
    d\x20this\x20log\n\n\x0f\n\x05\x04\x0f\x02\0\x04\x12\x06\xb0\x01\x02\xae\
    \x01\x17\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\xb0\x01\x02\x08\n\r\n\x05\
    \x04\x0f\x02\0\x01\x12\x04\xb0\x01\n\x11\n\r\n\x05\x04\x0f\x02\0\x03\x12\
    \x04\xb0\x01\x14\x15\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\xb1\x01\x02\x1c\
    \n\r\n\x05\x04\x0f\x02\x01\x04\x12\x04\xb1\x01\x02\n\n\r\n\x05\x04\x0f\
    \x02\x01\x05\x12\x04\xb1\x01\x0b\x11\n\r\n\x05\x04\x0f\x02\x01\x01\x12\
    \x04\xb1\x01\x12\x17\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xb1\x01\x1a\
    \x1b\n\x0c\n\x04\x04\x0f\x02\x02\x12\x04\xb2\x01\x02\x1b\n\r\n\x05\x04\
    \x0f\x02\x02\x04\x12\x04\xb2\x01\x02\n\n\r\n\x05\x04\x0f\x02\x02\x05\x12\
    \x04\xb2\x01\x0b\x11\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\xb2\x01\x12\
    \x16\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\xb2\x01\x19\x1ab\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
